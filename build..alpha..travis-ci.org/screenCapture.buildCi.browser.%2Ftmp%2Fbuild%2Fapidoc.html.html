<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/felipernb/algorithms.js/wiki">algorithms (v0.10.0)</a>
</h1>
<h4>Traditional computer science algorithms and data structures implemented in JavaScript</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.algorithms">module algorithms</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.AVLTree">
            function <span class="apidocSignatureSpan">algorithms.</span>DataStructures.AVLTree
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.BST">
            function <span class="apidocSignatureSpan">algorithms.</span>DataStructures.BST
            <span class="apidocSignatureSpan">(compareFn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.DisjointSetForest">
            function <span class="apidocSignatureSpan">algorithms.</span>DataStructures.DisjointSetForest
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.FenwickTree">
            function <span class="apidocSignatureSpan">algorithms.</span>DataStructures.FenwickTree
            <span class="apidocSignatureSpan">(length)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.Graph">
            function <span class="apidocSignatureSpan">algorithms.</span>DataStructures.Graph
            <span class="apidocSignatureSpan">(directed)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.HashTable">
            function <span class="apidocSignatureSpan">algorithms.</span>DataStructures.HashTable
            <span class="apidocSignatureSpan">(initialCapacity)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.LinkedList">
            function <span class="apidocSignatureSpan">algorithms.</span>DataStructures.LinkedList
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.PriorityQueue">
            function <span class="apidocSignatureSpan">algorithms.</span>DataStructures.PriorityQueue
            <span class="apidocSignatureSpan">(initialItems)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.Queue">
            function <span class="apidocSignatureSpan">algorithms.</span>DataStructures.Queue
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.Set">
            function <span class="apidocSignatureSpan">algorithms.</span>DataStructures.Set
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.Stack">
            function <span class="apidocSignatureSpan">algorithms.</span>DataStructures.Stack
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.Treap">
            function <span class="apidocSignatureSpan">algorithms.</span>DataStructures.Treap
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.Geometry.BezierCurve">
            function <span class="apidocSignatureSpan">algorithms.</span>Geometry.BezierCurve
            <span class="apidocSignatureSpan">(points)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.Math.fibonacci">
            function <span class="apidocSignatureSpan">algorithms.</span>Math.fibonacci
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.Math.gcd">
            function <span class="apidocSignatureSpan">algorithms.</span>Math.gcd
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.Math.lcm">
            function <span class="apidocSignatureSpan">algorithms.</span>Math.lcm
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.Math.powerSet">
            function <span class="apidocSignatureSpan">algorithms.</span>Math.powerSet
            <span class="apidocSignatureSpan">(array)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.Search.dfs">
            function <span class="apidocSignatureSpan">algorithms.</span>Search.dfs
            <span class="apidocSignatureSpan">(node, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.comparator">
            function <span class="apidocSignatureSpan">algorithms.</span>comparator
            <span class="apidocSignatureSpan">(compareFn)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">algorithms.</span>DataStructures</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">algorithms.</span>DataStructures.AVLTree.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">algorithms.</span>DataStructures.BST.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">algorithms.</span>DataStructures.DisjointSetForest.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">algorithms.</span>DataStructures.FenwickTree.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">algorithms.</span>DataStructures.Graph.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">algorithms.</span>DataStructures.HashTable.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">algorithms.</span>DataStructures.Heap</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">algorithms.</span>DataStructures.Heap.MinHeap.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">algorithms.</span>DataStructures.LinkedList.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">algorithms.</span>DataStructures.PriorityQueue.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">algorithms.</span>DataStructures.Queue.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">algorithms.</span>DataStructures.Set.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">algorithms.</span>DataStructures.Stack.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">algorithms.</span>DataStructures.Treap.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">algorithms.</span>Geometry</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">algorithms.</span>Geometry.BezierCurve.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">algorithms.</span>Graph</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">algorithms.</span>Math</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">algorithms.</span>Math.collatzConjecture</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">algorithms.</span>Math.primalityTests</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">algorithms.</span>Search</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">algorithms.</span>Sorting</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">algorithms.</span>String</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">algorithms.</span>String.huffman</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">algorithms.</span>comparator.prototype</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.algorithms.DataStructures">module algorithms.DataStructures</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.AVLTree">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.</span>AVLTree
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.BST">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.</span>BST
            <span class="apidocSignatureSpan">(compareFn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.DisjointSetForest">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.</span>DisjointSetForest
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.FenwickTree">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.</span>FenwickTree
            <span class="apidocSignatureSpan">(length)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.Graph">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.</span>Graph
            <span class="apidocSignatureSpan">(directed)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.HashTable">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.</span>HashTable
            <span class="apidocSignatureSpan">(initialCapacity)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.LinkedList">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.</span>LinkedList
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.PriorityQueue">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.</span>PriorityQueue
            <span class="apidocSignatureSpan">(initialItems)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.Queue">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.</span>Queue
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.Set">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.</span>Set
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.Stack">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.</span>Stack
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.Treap">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.</span>Treap
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">algorithms.DataStructures.</span>Heap</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.algorithms.DataStructures.AVLTree">module algorithms.DataStructures.AVLTree</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.AVLTree.AVLTree">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.</span>AVLTree
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.algorithms.DataStructures.AVLTree.prototype">module algorithms.DataStructures.AVLTree.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.AVLTree.prototype._find">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.AVLTree.prototype.</span>_find
            <span class="apidocSignatureSpan">(value, current)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.AVLTree.prototype._findMax">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.AVLTree.prototype.</span>_findMax
            <span class="apidocSignatureSpan">(node, current)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.AVLTree.prototype._findMin">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.AVLTree.prototype.</span>_findMin
            <span class="apidocSignatureSpan">(node, current)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.AVLTree.prototype.find">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.AVLTree.prototype.</span>find
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.AVLTree.prototype.findMax">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.AVLTree.prototype.</span>findMax
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.AVLTree.prototype.findMin">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.AVLTree.prototype.</span>findMin
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.AVLTree.prototype.getNodeHeight">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.AVLTree.prototype.</span>getNodeHeight
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.AVLTree.prototype.getNodesToRestructureAfterInsert">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.AVLTree.prototype.</span>getNodesToRestructureAfterInsert
            <span class="apidocSignatureSpan">(traveledNodes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.AVLTree.prototype.getNodesToRestructureAfterRemove">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.AVLTree.prototype.</span>getNodesToRestructureAfterRemove
            <span class="apidocSignatureSpan">(traveledNodes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.AVLTree.prototype.getTreeHeight">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.AVLTree.prototype.</span>getTreeHeight
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.AVLTree.prototype.inOrder">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.AVLTree.prototype.</span>inOrder
            <span class="apidocSignatureSpan">(current, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.AVLTree.prototype.insert">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.AVLTree.prototype.</span>insert
            <span class="apidocSignatureSpan">(value, current)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.AVLTree.prototype.isNodeBalanced">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.AVLTree.prototype.</span>isNodeBalanced
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.AVLTree.prototype.isTreeBalanced">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.AVLTree.prototype.</span>isTreeBalanced
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.AVLTree.prototype.keepHeightBalance">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.AVLTree.prototype.</span>keepHeightBalance
            <span class="apidocSignatureSpan">(node, afterRemove)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.AVLTree.prototype.leftLeft">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.AVLTree.prototype.</span>leftLeft
            <span class="apidocSignatureSpan">(x, y, z)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.AVLTree.prototype.leftRight">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.AVLTree.prototype.</span>leftRight
            <span class="apidocSignatureSpan">(x, y, z)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.AVLTree.prototype.postOrder">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.AVLTree.prototype.</span>postOrder
            <span class="apidocSignatureSpan">(current, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.AVLTree.prototype.preOrder">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.AVLTree.prototype.</span>preOrder
            <span class="apidocSignatureSpan">(current, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.AVLTree.prototype.remove">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.AVLTree.prototype.</span>remove
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.AVLTree.prototype.replaceChild">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.AVLTree.prototype.</span>replaceChild
            <span class="apidocSignatureSpan">(parent, oldChild, newChild)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.AVLTree.prototype.restructure">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.AVLTree.prototype.</span>restructure
            <span class="apidocSignatureSpan">(nodesToRestructure)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.AVLTree.prototype.rightLeft">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.AVLTree.prototype.</span>rightLeft
            <span class="apidocSignatureSpan">(x, y, z)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.AVLTree.prototype.rightRight">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.AVLTree.prototype.</span>rightRight
            <span class="apidocSignatureSpan">(x, y, z)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.algorithms.DataStructures.BST">module algorithms.DataStructures.BST</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.BST.BST">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.</span>BST
            <span class="apidocSignatureSpan">(compareFn)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.algorithms.DataStructures.BST.prototype">module algorithms.DataStructures.BST.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.BST.prototype._find">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.BST.prototype.</span>_find
            <span class="apidocSignatureSpan">(e, root)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.BST.prototype._findMin">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.BST.prototype.</span>_findMin
            <span class="apidocSignatureSpan">(root)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.BST.prototype._replaceNodeInParent">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.BST.prototype.</span>_replaceNodeInParent
            <span class="apidocSignatureSpan">(currNode, newNode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.BST.prototype.contains">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.BST.prototype.</span>contains
            <span class="apidocSignatureSpan">(e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.BST.prototype.insert">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.BST.prototype.</span>insert
            <span class="apidocSignatureSpan">(value, parent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.BST.prototype.remove">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.BST.prototype.</span>remove
            <span class="apidocSignatureSpan">(e)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.algorithms.DataStructures.DisjointSetForest">module algorithms.DataStructures.DisjointSetForest</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.DisjointSetForest.DisjointSetForest">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.</span>DisjointSetForest
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.algorithms.DataStructures.DisjointSetForest.prototype">module algorithms.DataStructures.DisjointSetForest.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.DisjointSetForest.prototype._introduce">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.DisjointSetForest.prototype.</span>_introduce
            <span class="apidocSignatureSpan">(element)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.DisjointSetForest.prototype.merge">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.DisjointSetForest.prototype.</span>merge
            <span class="apidocSignatureSpan">(element1, element2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.DisjointSetForest.prototype.root">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.DisjointSetForest.prototype.</span>root
            <span class="apidocSignatureSpan">(element)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.DisjointSetForest.prototype.sameSubset">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.DisjointSetForest.prototype.</span>sameSubset
            <span class="apidocSignatureSpan">(element)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.DisjointSetForest.prototype.size">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.DisjointSetForest.prototype.</span>size
            <span class="apidocSignatureSpan">(element)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.algorithms.DataStructures.FenwickTree">module algorithms.DataStructures.FenwickTree</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.FenwickTree.FenwickTree">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.</span>FenwickTree
            <span class="apidocSignatureSpan">(length)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.algorithms.DataStructures.FenwickTree.prototype">module algorithms.DataStructures.FenwickTree.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.FenwickTree.prototype.adjust">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.FenwickTree.prototype.</span>adjust
            <span class="apidocSignatureSpan">(index, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.FenwickTree.prototype.prefixSum">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.FenwickTree.prototype.</span>prefixSum
            <span class="apidocSignatureSpan">(index)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.FenwickTree.prototype.rangeSum">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.FenwickTree.prototype.</span>rangeSum
            <span class="apidocSignatureSpan">(fromIndex, toIndex)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.algorithms.DataStructures.Graph">module algorithms.DataStructures.Graph</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.Graph.Graph">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.</span>Graph
            <span class="apidocSignatureSpan">(directed)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.algorithms.DataStructures.Graph.prototype">module algorithms.DataStructures.Graph.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.Graph.prototype.addEdge">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.Graph.prototype.</span>addEdge
            <span class="apidocSignatureSpan">(a, b, w)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.Graph.prototype.addVertex">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.Graph.prototype.</span>addVertex
            <span class="apidocSignatureSpan">(v)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.Graph.prototype.edge">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.Graph.prototype.</span>edge
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.Graph.prototype.neighbors">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.Graph.prototype.</span>neighbors
            <span class="apidocSignatureSpan">(v)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.algorithms.DataStructures.HashTable">module algorithms.DataStructures.HashTable</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.HashTable.HashTable">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.</span>HashTable
            <span class="apidocSignatureSpan">(initialCapacity)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.algorithms.DataStructures.HashTable.prototype">module algorithms.DataStructures.HashTable.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.HashTable.prototype._findInList">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.HashTable.prototype.</span>_findInList
            <span class="apidocSignatureSpan">(list, key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.HashTable.prototype._increaseCapacity">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.HashTable.prototype.</span>_increaseCapacity
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.HashTable.prototype._position">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.HashTable.prototype.</span>_position
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.HashTable.prototype.del">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.HashTable.prototype.</span>del
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.HashTable.prototype.forEach">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.HashTable.prototype.</span>forEach
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.HashTable.prototype.get">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.HashTable.prototype.</span>get
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.HashTable.prototype.hash">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.HashTable.prototype.</span>hash
            <span class="apidocSignatureSpan">(s)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.HashTable.prototype.put">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.HashTable.prototype.</span>put
            <span class="apidocSignatureSpan">(key, value)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.algorithms.DataStructures.Heap">module algorithms.DataStructures.Heap</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.Heap.MaxHeap">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.Heap.</span>MaxHeap
            <span class="apidocSignatureSpan">(compareFn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.Heap.MinHeap">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.Heap.</span>MinHeap
            <span class="apidocSignatureSpan">(compareFn)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.algorithms.DataStructures.Heap.MinHeap.prototype">module algorithms.DataStructures.Heap.MinHeap.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.Heap.MinHeap.prototype._siftDown">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.Heap.MinHeap.prototype.</span>_siftDown
            <span class="apidocSignatureSpan">(i)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.Heap.MinHeap.prototype._siftUp">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.Heap.MinHeap.prototype.</span>_siftUp
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.Heap.MinHeap.prototype._swap">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.Heap.MinHeap.prototype.</span>_swap
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.Heap.MinHeap.prototype.extract">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.Heap.MinHeap.prototype.</span>extract
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.Heap.MinHeap.prototype.forEach">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.Heap.MinHeap.prototype.</span>forEach
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.Heap.MinHeap.prototype.heapify">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.Heap.MinHeap.prototype.</span>heapify
            <span class="apidocSignatureSpan">(a)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.Heap.MinHeap.prototype.insert">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.Heap.MinHeap.prototype.</span>insert
            <span class="apidocSignatureSpan">(e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.Heap.MinHeap.prototype.isEmpty">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.Heap.MinHeap.prototype.</span>isEmpty
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.algorithms.DataStructures.LinkedList">module algorithms.DataStructures.LinkedList</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.LinkedList.LinkedList">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.</span>LinkedList
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.algorithms.DataStructures.LinkedList.prototype">module algorithms.DataStructures.LinkedList.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.LinkedList.prototype.add">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.LinkedList.prototype.</span>add
            <span class="apidocSignatureSpan">(n, index)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.LinkedList.prototype.del">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.LinkedList.prototype.</span>del
            <span class="apidocSignatureSpan">(index)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.LinkedList.prototype.delNode">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.LinkedList.prototype.</span>delNode
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.LinkedList.prototype.forEach">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.LinkedList.prototype.</span>forEach
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.LinkedList.prototype.get">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.LinkedList.prototype.</span>get
            <span class="apidocSignatureSpan">(index)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.LinkedList.prototype.getNode">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.LinkedList.prototype.</span>getNode
            <span class="apidocSignatureSpan">(index)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.LinkedList.prototype.isEmpty">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.LinkedList.prototype.</span>isEmpty
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.algorithms.DataStructures.PriorityQueue">module algorithms.DataStructures.PriorityQueue</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.PriorityQueue.PriorityQueue">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.</span>PriorityQueue
            <span class="apidocSignatureSpan">(initialItems)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.algorithms.DataStructures.PriorityQueue.prototype">module algorithms.DataStructures.PriorityQueue.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.PriorityQueue.prototype.changePriority">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.PriorityQueue.prototype.</span>changePriority
            <span class="apidocSignatureSpan">(item, priority)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.PriorityQueue.prototype.extract">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.PriorityQueue.prototype.</span>extract
            <span class="apidocSignatureSpan">(withPriority)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.PriorityQueue.prototype.insert">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.PriorityQueue.prototype.</span>insert
            <span class="apidocSignatureSpan">(item, priority)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.PriorityQueue.prototype.priority">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.PriorityQueue.prototype.</span>priority
            <span class="apidocSignatureSpan">(item)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">algorithms.DataStructures.PriorityQueue.prototype.</span>_comparator</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">algorithms.DataStructures.PriorityQueue.prototype.</span>_elements</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.algorithms.DataStructures.Queue">module algorithms.DataStructures.Queue</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.Queue.Queue">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.</span>Queue
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.algorithms.DataStructures.Queue.prototype">module algorithms.DataStructures.Queue.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.Queue.prototype.forEach">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.Queue.prototype.</span>forEach
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.Queue.prototype.isEmpty">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.Queue.prototype.</span>isEmpty
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.Queue.prototype.peek">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.Queue.prototype.</span>peek
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.Queue.prototype.pop">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.Queue.prototype.</span>pop
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.Queue.prototype.push">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.Queue.prototype.</span>push
            <span class="apidocSignatureSpan">(e)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.algorithms.DataStructures.Set">module algorithms.DataStructures.Set</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.Set.Set">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.</span>Set
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.algorithms.DataStructures.Set.prototype">module algorithms.DataStructures.Set.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.Set.prototype.add">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.Set.prototype.</span>add
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.Set.prototype.contains">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.Set.prototype.</span>contains
            <span class="apidocSignatureSpan">(e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.Set.prototype.forEach">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.Set.prototype.</span>forEach
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.Set.prototype.remove">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.Set.prototype.</span>remove
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.algorithms.DataStructures.Stack">module algorithms.DataStructures.Stack</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.Stack.Stack">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.</span>Stack
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.algorithms.DataStructures.Stack.prototype">module algorithms.DataStructures.Stack.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.Stack.prototype.push">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.Stack.prototype.</span>push
            <span class="apidocSignatureSpan">(e)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">algorithms.DataStructures.Stack.prototype.</span>_elements</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.algorithms.DataStructures.Treap">module algorithms.DataStructures.Treap</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.Treap.Treap">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.</span>Treap
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.algorithms.DataStructures.Treap.prototype">module algorithms.DataStructures.Treap.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.Treap.prototype._find">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.Treap.prototype.</span>_find
            <span class="apidocSignatureSpan">(node, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.Treap.prototype._insert">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.Treap.prototype.</span>_insert
            <span class="apidocSignatureSpan">(node, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.Treap.prototype._maximum">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.Treap.prototype.</span>_maximum
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.Treap.prototype._minimum">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.Treap.prototype.</span>_minimum
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.Treap.prototype._remove">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.Treap.prototype.</span>_remove
            <span class="apidocSignatureSpan">(node, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.Treap.prototype.find">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.Treap.prototype.</span>find
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.Treap.prototype.height">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.Treap.prototype.</span>height
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.Treap.prototype.insert">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.Treap.prototype.</span>insert
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.Treap.prototype.maximum">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.Treap.prototype.</span>maximum
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.Treap.prototype.minimum">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.Treap.prototype.</span>minimum
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.Treap.prototype.remove">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.Treap.prototype.</span>remove
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.DataStructures.Treap.prototype.size">
            function <span class="apidocSignatureSpan">algorithms.DataStructures.Treap.prototype.</span>size
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.algorithms.Geometry">module algorithms.Geometry</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.Geometry.BezierCurve">
            function <span class="apidocSignatureSpan">algorithms.Geometry.</span>BezierCurve
            <span class="apidocSignatureSpan">(points)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.algorithms.Geometry.BezierCurve">module algorithms.Geometry.BezierCurve</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.Geometry.BezierCurve.BezierCurve">
            function <span class="apidocSignatureSpan">algorithms.Geometry.</span>BezierCurve
            <span class="apidocSignatureSpan">(points)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.algorithms.Geometry.BezierCurve.prototype">module algorithms.Geometry.BezierCurve.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.Geometry.BezierCurve.prototype.get">
            function <span class="apidocSignatureSpan">algorithms.Geometry.BezierCurve.prototype.</span>get
            <span class="apidocSignatureSpan">(t)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.algorithms.Graph">module algorithms.Graph</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.Graph.SPFA">
            function <span class="apidocSignatureSpan">algorithms.Graph.</span>SPFA
            <span class="apidocSignatureSpan">(graph, s)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.Graph.bellmanFord">
            function <span class="apidocSignatureSpan">algorithms.Graph.</span>bellmanFord
            <span class="apidocSignatureSpan">(graph, startNode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.Graph.bfsShortestPath">
            function <span class="apidocSignatureSpan">algorithms.Graph.</span>bfsShortestPath
            <span class="apidocSignatureSpan">(graph, source)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.Graph.breadthFirstSearch">
            function <span class="apidocSignatureSpan">algorithms.Graph.</span>breadthFirstSearch
            <span class="apidocSignatureSpan">(graph, startVertex, callbacks)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.Graph.depthFirstSearch">
            function <span class="apidocSignatureSpan">algorithms.Graph.</span>depthFirstSearch
            <span class="apidocSignatureSpan">(graph, startVertex, callbacks)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.Graph.dijkstra">
            function <span class="apidocSignatureSpan">algorithms.Graph.</span>dijkstra
            <span class="apidocSignatureSpan">(graph, s)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.Graph.eulerPath">
            function <span class="apidocSignatureSpan">algorithms.Graph.</span>eulerPath
            <span class="apidocSignatureSpan">(graph)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.Graph.floydWarshall">
            function <span class="apidocSignatureSpan">algorithms.Graph.</span>floydWarshall
            <span class="apidocSignatureSpan">(graph)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.Graph.kruskal">
            function <span class="apidocSignatureSpan">algorithms.Graph.</span>kruskal
            <span class="apidocSignatureSpan">(graph)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.Graph.prim">
            function <span class="apidocSignatureSpan">algorithms.Graph.</span>prim
            <span class="apidocSignatureSpan">(graph)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.Graph.topologicalSort">
            function <span class="apidocSignatureSpan">algorithms.Graph.</span>topologicalSort
            <span class="apidocSignatureSpan">(graph)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.algorithms.Math">module algorithms.Math</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.Math.extendedEuclidean">
            function <span class="apidocSignatureSpan">algorithms.Math.</span>extendedEuclidean
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.Math.fastPower">
            function <span class="apidocSignatureSpan">algorithms.Math.</span>fastPower
            <span class="apidocSignatureSpan">(base, power, mul, identity)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.Math.fibonacci">
            function <span class="apidocSignatureSpan">algorithms.Math.</span>fibonacci
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.Math.fisherYates">
            function <span class="apidocSignatureSpan">algorithms.Math.</span>fisherYates
            <span class="apidocSignatureSpan">(a)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.Math.gcd">
            function <span class="apidocSignatureSpan">algorithms.Math.</span>gcd
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.Math.greatestDifference">
            function <span class="apidocSignatureSpan">algorithms.Math.</span>greatestDifference
            <span class="apidocSignatureSpan">(numbers)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.Math.lcm">
            function <span class="apidocSignatureSpan">algorithms.Math.</span>lcm
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.Math.newtonSqrt">
            function <span class="apidocSignatureSpan">algorithms.Math.</span>newtonSqrt
            <span class="apidocSignatureSpan">(n, tolerance, maxIterations)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.Math.nextPermutation">
            function <span class="apidocSignatureSpan">algorithms.Math.</span>nextPermutation
            <span class="apidocSignatureSpan">(array, compareFn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.Math.powerSet">
            function <span class="apidocSignatureSpan">algorithms.Math.</span>powerSet
            <span class="apidocSignatureSpan">(array)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.Math.reservoirSampling">
            function <span class="apidocSignatureSpan">algorithms.Math.</span>reservoirSampling
            <span class="apidocSignatureSpan">(array, sampleSize)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.Math.shannonEntropy">
            function <span class="apidocSignatureSpan">algorithms.Math.</span>shannonEntropy
            <span class="apidocSignatureSpan">(arr)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">algorithms.Math.</span>collatzConjecture</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">algorithms.Math.</span>primalityTests</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.algorithms.Math.collatzConjecture">module algorithms.Math.collatzConjecture</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.Math.collatzConjecture.calculate">
            function <span class="apidocSignatureSpan">algorithms.Math.collatzConjecture.</span>calculate
            <span class="apidocSignatureSpan">(number)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.Math.collatzConjecture.generate">
            function <span class="apidocSignatureSpan">algorithms.Math.collatzConjecture.</span>generate
            <span class="apidocSignatureSpan">(number)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.algorithms.Math.fibonacci">module algorithms.Math.fibonacci</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.Math.fibonacci.fibonacci">
            function <span class="apidocSignatureSpan">algorithms.Math.</span>fibonacci
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.Math.fibonacci.direct">
            function <span class="apidocSignatureSpan">algorithms.Math.fibonacci.</span>direct
            <span class="apidocSignatureSpan">(number)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.Math.fibonacci.exponential">
            function <span class="apidocSignatureSpan">algorithms.Math.fibonacci.</span>exponential
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.Math.fibonacci.logarithmic">
            function <span class="apidocSignatureSpan">algorithms.Math.fibonacci.</span>logarithmic
            <span class="apidocSignatureSpan">(number)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.Math.fibonacci.withMemoization">
            function <span class="apidocSignatureSpan">algorithms.Math.fibonacci.</span>withMemoization
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.algorithms.Math.gcd">module algorithms.Math.gcd</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.Math.gcd.gcd">
            function <span class="apidocSignatureSpan">algorithms.Math.</span>gcd
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.Math.gcd.binary">
            function <span class="apidocSignatureSpan">algorithms.Math.gcd.</span>binary
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.algorithms.Math.lcm">module algorithms.Math.lcm</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.Math.lcm.lcm">
            function <span class="apidocSignatureSpan">algorithms.Math.</span>lcm
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.Math.lcm.binary">
            function <span class="apidocSignatureSpan">algorithms.Math.lcm.</span>binary
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.algorithms.Math.powerSet">module algorithms.Math.powerSet</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.Math.powerSet.powerSet">
            function <span class="apidocSignatureSpan">algorithms.Math.</span>powerSet
            <span class="apidocSignatureSpan">(array)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.Math.powerSet.recursive">
            function <span class="apidocSignatureSpan">algorithms.Math.powerSet.</span>recursive
            <span class="apidocSignatureSpan">(array)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.algorithms.Math.primalityTests">module algorithms.Math.primalityTests</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.Math.primalityTests.naiveTest">
            function <span class="apidocSignatureSpan">algorithms.Math.primalityTests.</span>naiveTest
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.Math.primalityTests.trialDivisionTest">
            function <span class="apidocSignatureSpan">algorithms.Math.primalityTests.</span>trialDivisionTest
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.algorithms.Search">module algorithms.Search</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.Search.bfs">
            function <span class="apidocSignatureSpan">algorithms.Search.</span>bfs
            <span class="apidocSignatureSpan">(root, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.Search.binarySearch">
            function <span class="apidocSignatureSpan">algorithms.Search.</span>binarySearch
            <span class="apidocSignatureSpan">(sortedArray, element)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.Search.dfs">
            function <span class="apidocSignatureSpan">algorithms.Search.</span>dfs
            <span class="apidocSignatureSpan">(node, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.Search.ternarySearch">
            function <span class="apidocSignatureSpan">algorithms.Search.</span>ternarySearch
            <span class="apidocSignatureSpan">(fn, left, right, precision)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.algorithms.Search.dfs">module algorithms.Search.dfs</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.Search.dfs.dfs">
            function <span class="apidocSignatureSpan">algorithms.Search.</span>dfs
            <span class="apidocSignatureSpan">(node, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.Search.dfs.postOrder">
            function <span class="apidocSignatureSpan">algorithms.Search.dfs.</span>postOrder
            <span class="apidocSignatureSpan">(node, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.Search.dfs.preOrder">
            function <span class="apidocSignatureSpan">algorithms.Search.dfs.</span>preOrder
            <span class="apidocSignatureSpan">(node, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.algorithms.Sorting">module algorithms.Sorting</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.Sorting.bubbleSort">
            function <span class="apidocSignatureSpan">algorithms.Sorting.</span>bubbleSort
            <span class="apidocSignatureSpan">(a, comparatorFn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.Sorting.countingSort">
            function <span class="apidocSignatureSpan">algorithms.Sorting.</span>countingSort
            <span class="apidocSignatureSpan">(array)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.Sorting.heapSort">
            function <span class="apidocSignatureSpan">algorithms.Sorting.</span>heapSort
            <span class="apidocSignatureSpan">(array, comparatorFn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.Sorting.insertionSort">
            function <span class="apidocSignatureSpan">algorithms.Sorting.</span>insertionSort
            <span class="apidocSignatureSpan">(vector, comparatorFn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.Sorting.mergeSort">
            function <span class="apidocSignatureSpan">algorithms.Sorting.</span>mergeSort
            <span class="apidocSignatureSpan">(a, compareFn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.Sorting.quicksort">
            function <span class="apidocSignatureSpan">algorithms.Sorting.</span>quicksort
            <span class="apidocSignatureSpan">(array, comparatorFn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.Sorting.radixSort">
            function <span class="apidocSignatureSpan">algorithms.Sorting.</span>radixSort
            <span class="apidocSignatureSpan">(array)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.Sorting.selectionSort">
            function <span class="apidocSignatureSpan">algorithms.Sorting.</span>selectionSort
            <span class="apidocSignatureSpan">(a, comparatorFn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.Sorting.shellSort">
            function <span class="apidocSignatureSpan">algorithms.Sorting.</span>shellSort
            <span class="apidocSignatureSpan">(array, comparatorFn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.Sorting.shortBubbleSort">
            function <span class="apidocSignatureSpan">algorithms.Sorting.</span>shortBubbleSort
            <span class="apidocSignatureSpan">(array, comparatorFn)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.algorithms.String">module algorithms.String</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.String.hamming">
            function <span class="apidocSignatureSpan">algorithms.String.</span>hamming
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.String.knuthMorrisPratt">
            function <span class="apidocSignatureSpan">algorithms.String.</span>knuthMorrisPratt
            <span class="apidocSignatureSpan">(text, pattern)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.String.levenshtein">
            function <span class="apidocSignatureSpan">algorithms.String.</span>levenshtein
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.String.longestCommonSubsequence">
            function <span class="apidocSignatureSpan">algorithms.String.</span>longestCommonSubsequence
            <span class="apidocSignatureSpan">(s1, s2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.String.longestCommonSubstring">
            function <span class="apidocSignatureSpan">algorithms.String.</span>longestCommonSubstring
            <span class="apidocSignatureSpan">(s1, s2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.String.rabinKarp">
            function <span class="apidocSignatureSpan">algorithms.String.</span>rabinKarp
            <span class="apidocSignatureSpan">(s, pattern)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">algorithms.String.</span>huffman</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.algorithms.String.huffman">module algorithms.String.huffman</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.String.huffman.decode">
            function <span class="apidocSignatureSpan">algorithms.String.huffman.</span>decode
            <span class="apidocSignatureSpan">(encoding, encodedString)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.String.huffman.encode">
            function <span class="apidocSignatureSpan">algorithms.String.huffman.</span>encode
            <span class="apidocSignatureSpan">(string, compressed)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.algorithms.comparator">module algorithms.comparator</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.comparator.comparator">
            function <span class="apidocSignatureSpan">algorithms.</span>comparator
            <span class="apidocSignatureSpan">(compareFn)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.algorithms.comparator.prototype">module algorithms.comparator.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.comparator.prototype.compare">
            function <span class="apidocSignatureSpan">algorithms.comparator.prototype.</span>compare
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.comparator.prototype.equal">
            function <span class="apidocSignatureSpan">algorithms.comparator.prototype.</span>equal
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.comparator.prototype.greaterThan">
            function <span class="apidocSignatureSpan">algorithms.comparator.prototype.</span>greaterThan
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.comparator.prototype.greaterThanOrEqual">
            function <span class="apidocSignatureSpan">algorithms.comparator.prototype.</span>greaterThanOrEqual
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.comparator.prototype.lessThan">
            function <span class="apidocSignatureSpan">algorithms.comparator.prototype.</span>lessThan
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.comparator.prototype.lessThanOrEqual">
            function <span class="apidocSignatureSpan">algorithms.comparator.prototype.</span>lessThanOrEqual
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.algorithms.comparator.prototype.reverse">
            function <span class="apidocSignatureSpan">algorithms.comparator.prototype.</span>reverse
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.algorithms" id="apidoc.module.algorithms">module algorithms</a></h1>


    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.AVLTree" id="apidoc.element.algorithms.DataStructures.AVLTree">
        function <span class="apidocSignatureSpan">algorithms.</span>DataStructures.AVLTree
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function AVLTree() {
  this.root = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.BST" id="apidoc.element.algorithms.DataStructures.BST">
        function <span class="apidocSignatureSpan">algorithms.</span>DataStructures.BST
        <span class="apidocSignatureSpan">(compareFn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BST(compareFn) {
  this.root = null;
  this._size = 0;
<span class="apidocCodeCommentSpan">  /**
   * @var Comparator
   */
</span>  this._comparator = new Comparator(compareFn);

  /**
   * Read-only property for the size of the tree
   */
  Object.defineProperty(this, 'size', {
    get: function () { return this._size; }.bind(this)
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.DisjointSetForest" id="apidoc.element.algorithms.DataStructures.DisjointSetForest">
        function <span class="apidocSignatureSpan">algorithms.</span>DataStructures.DisjointSetForest
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DisjointSetForest() {
  this._parents = {};
  this._ranks = {};
  this._sizes = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.FenwickTree" id="apidoc.element.algorithms.DataStructures.FenwickTree">
        function <span class="apidocSignatureSpan">algorithms.</span>DataStructures.FenwickTree
        <span class="apidocSignatureSpan">(length)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function FenwickTree(length) {
  this._elements = new Array(length + 1);
  for (var i = 0; i &lt; this._elements.length ; i++)
    this._elements[i] = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.Graph" id="apidoc.element.algorithms.DataStructures.Graph">
        function <span class="apidocSignatureSpan">algorithms.</span>DataStructures.Graph
        <span class="apidocSignatureSpan">(directed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Graph(directed) {
  this.directed = (directed === undefined ? true : !!directed);
  this.adjList = Object.create(null);
  this.vertices = new HashSet();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.HashTable" id="apidoc.element.algorithms.DataStructures.HashTable">
        function <span class="apidocSignatureSpan">algorithms.</span>DataStructures.HashTable
        <span class="apidocSignatureSpan">(initialCapacity)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function HashTable(initialCapacity) {
  this._table = new Array(initialCapacity || 64);
  this._items = 0;

  Object.defineProperty(this, 'capacity', {
    get: function () {
      return this._table.length;
    }
  });

  Object.defineProperty(this, 'size', {
    get: function () {
      return this._items;
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.LinkedList" id="apidoc.element.algorithms.DataStructures.LinkedList">
        function <span class="apidocSignatureSpan">algorithms.</span>DataStructures.LinkedList
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function LinkedList() {

  this._length = 0;
  this.head = null;
  this.tail = null;

  // Read-only length property
  Object.defineProperty(this, 'length', {
    get: function () {
      return this._length;
    }.bind(this)
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.PriorityQueue" id="apidoc.element.algorithms.DataStructures.PriorityQueue">
        function <span class="apidocSignatureSpan">algorithms.</span>DataStructures.PriorityQueue
        <span class="apidocSignatureSpan">(initialItems)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function PriorityQueue(initialItems) {

  var self = this;
  MinHeap.call(this, function (a, b) {
    return self.priority(a) &lt; self.priority(b) ? -1 : 1;
  });

  this._priority = {};

  initialItems = initialItems || {};
  Object.keys(initialItems).forEach(function (item) {
    self.insert(item, initialItems[item]);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.Queue" id="apidoc.element.algorithms.DataStructures.Queue">
        function <span class="apidocSignatureSpan">algorithms.</span>DataStructures.Queue
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Queue() {
  this._elements = new LinkedList();

  Object.defineProperty(this, 'length', {
    get: function () {
      return this._elements.length;
    }.bind(this)
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.Set" id="apidoc.element.algorithms.DataStructures.Set">
        function <span class="apidocSignatureSpan">algorithms.</span>DataStructures.Set
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">DataStructures.Set = function () {
  this._elements = new HashTable(arguments.length);
  this.add.apply(this, arguments);

  Object.defineProperty(this, 'size', {
    get: function () {
      return this._elements.size;
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.Stack" id="apidoc.element.algorithms.DataStructures.Stack">
        function <span class="apidocSignatureSpan">algorithms.</span>DataStructures.Stack
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Stack() {
  Queue.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.Treap" id="apidoc.element.algorithms.DataStructures.Treap">
        function <span class="apidocSignatureSpan">algorithms.</span>DataStructures.Treap
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Treap() {
  this.root = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.Geometry.BezierCurve" id="apidoc.element.algorithms.Geometry.BezierCurve">
        function <span class="apidocSignatureSpan">algorithms.</span>Geometry.BezierCurve
        <span class="apidocSignatureSpan">(points)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Geometry.BezierCurve = function (points) {
  this.n = points.length;
  this.p = [];

  // The binomial coefficient
  var c = [1];
  var i, j;
  for (i = 1; i &lt; this.n; ++i) {
    c.push(0);
    for (j = i; j &gt;= 1; --j) {
        c[j] += c[j - 1];
    }
  }

  // the i-th control point times the coefficient
  for (i = 0; i &lt; this.n; ++i) {
    this.p.push({x: c[i] * points[i].x, y: c[i] * points[i].y});
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.Math.fibonacci" id="apidoc.element.algorithms.Math.fibonacci">
        function <span class="apidocSignatureSpan">algorithms.</span>Math.fibonacci
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Math.fibonacci = function (n) {
  var fibNMinus2 = 0,
      fibNMinus1 = 1,
      fib = n;
  for (var i = 1; i &lt; n; i++) {
    fib = fibNMinus1 + fibNMinus2;
    fibNMinus2 = fibNMinus1;
    fibNMinus1 = fib;
  }
  return fib;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.Math.gcd" id="apidoc.element.algorithms.Math.gcd">
        function <span class="apidocSignatureSpan">algorithms.</span>Math.gcd
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Math.gcd = function (a, b) {
  var tmp = a;
  a = Math.max(a, b);
  b = Math.min(tmp, b);
  while (b !== 0) {
    tmp = b;
    b = a % b;
    a = tmp;
  }

  return a;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.Math.lcm" id="apidoc.element.algorithms.Math.lcm">
        function <span class="apidocSignatureSpan">algorithms.</span>Math.lcm
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Math.lcm = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.Math.powerSet" id="apidoc.element.algorithms.Math.powerSet">
        function <span class="apidocSignatureSpan">algorithms.</span>Math.powerSet
        <span class="apidocSignatureSpan">(array)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Math.powerSet = function (array) {

  if (array.length === 0) {
    return [];
  }

  var powerSet = [];
  var cache = [];
  var i;

  for (i = 0; i &lt; array.length; i++) {
    cache[i] = true;
  }

  for (i = 0; i &lt; Math.pow(2, array.length); i++) {

    powerSet.push([]);

    for (var j = 0; j &lt; array.length; j++) {

      if (i % Math.pow(2, j) === 0) {
        cache[j] = !cache[j];
      }

      if (cache[j]) {
        powerSet[i].push(array[j]);
      }

    }
  }

  return powerSet;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.Search.dfs" id="apidoc.element.algorithms.Search.dfs">
        function <span class="apidocSignatureSpan">algorithms.</span>Search.dfs
        <span class="apidocSignatureSpan">(node, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Search.dfs = function (node, callback) {
  if (node) {
    inOrder(node.left, callback);
    callback(node.value);
    inOrder(node.right, callback);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.comparator" id="apidoc.element.algorithms.comparator">
        function <span class="apidocSignatureSpan">algorithms.</span>comparator
        <span class="apidocSignatureSpan">(compareFn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Comparator(compareFn) {
  if (compareFn) {
    this.compare = compareFn;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






















































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.algorithms.DataStructures" id="apidoc.module.algorithms.DataStructures">module algorithms.DataStructures</a></h1>


    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.AVLTree" id="apidoc.element.algorithms.DataStructures.AVLTree">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.</span>AVLTree
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function AVLTree() {
  this.root = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.BST" id="apidoc.element.algorithms.DataStructures.BST">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.</span>BST
        <span class="apidocSignatureSpan">(compareFn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BST(compareFn) {
  this.root = null;
  this._size = 0;
<span class="apidocCodeCommentSpan">  /**
   * @var Comparator
   */
</span>  this._comparator = new Comparator(compareFn);

  /**
   * Read-only property for the size of the tree
   */
  Object.defineProperty(this, 'size', {
    get: function () { return this._size; }.bind(this)
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.DisjointSetForest" id="apidoc.element.algorithms.DataStructures.DisjointSetForest">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.</span>DisjointSetForest
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DisjointSetForest() {
  this._parents = {};
  this._ranks = {};
  this._sizes = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.FenwickTree" id="apidoc.element.algorithms.DataStructures.FenwickTree">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.</span>FenwickTree
        <span class="apidocSignatureSpan">(length)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function FenwickTree(length) {
  this._elements = new Array(length + 1);
  for (var i = 0; i &lt; this._elements.length ; i++)
    this._elements[i] = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.Graph" id="apidoc.element.algorithms.DataStructures.Graph">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.</span>Graph
        <span class="apidocSignatureSpan">(directed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Graph(directed) {
  this.directed = (directed === undefined ? true : !!directed);
  this.adjList = Object.create(null);
  this.vertices = new HashSet();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.HashTable" id="apidoc.element.algorithms.DataStructures.HashTable">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.</span>HashTable
        <span class="apidocSignatureSpan">(initialCapacity)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function HashTable(initialCapacity) {
  this._table = new Array(initialCapacity || 64);
  this._items = 0;

  Object.defineProperty(this, 'capacity', {
    get: function () {
      return this._table.length;
    }
  });

  Object.defineProperty(this, 'size', {
    get: function () {
      return this._items;
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.LinkedList" id="apidoc.element.algorithms.DataStructures.LinkedList">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.</span>LinkedList
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function LinkedList() {

  this._length = 0;
  this.head = null;
  this.tail = null;

  // Read-only length property
  Object.defineProperty(this, 'length', {
    get: function () {
      return this._length;
    }.bind(this)
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.PriorityQueue" id="apidoc.element.algorithms.DataStructures.PriorityQueue">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.</span>PriorityQueue
        <span class="apidocSignatureSpan">(initialItems)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function PriorityQueue(initialItems) {

  var self = this;
  MinHeap.call(this, function (a, b) {
    return self.priority(a) &lt; self.priority(b) ? -1 : 1;
  });

  this._priority = {};

  initialItems = initialItems || {};
  Object.keys(initialItems).forEach(function (item) {
    self.insert(item, initialItems[item]);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.Queue" id="apidoc.element.algorithms.DataStructures.Queue">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.</span>Queue
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Queue() {
  this._elements = new LinkedList();

  Object.defineProperty(this, 'length', {
    get: function () {
      return this._elements.length;
    }.bind(this)
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.Set" id="apidoc.element.algorithms.DataStructures.Set">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.</span>Set
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Set = function () {
  this._elements = new HashTable(arguments.length);
  this.add.apply(this, arguments);

  Object.defineProperty(this, 'size', {
    get: function () {
      return this._elements.size;
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.Stack" id="apidoc.element.algorithms.DataStructures.Stack">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.</span>Stack
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Stack() {
  Queue.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.Treap" id="apidoc.element.algorithms.DataStructures.Treap">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.</span>Treap
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Treap() {
  this.root = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.algorithms.DataStructures.AVLTree" id="apidoc.module.algorithms.DataStructures.AVLTree">module algorithms.DataStructures.AVLTree</a></h1>


    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.AVLTree.AVLTree" id="apidoc.element.algorithms.DataStructures.AVLTree.AVLTree">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.</span>AVLTree
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function AVLTree() {
  this.root = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.algorithms.DataStructures.AVLTree.prototype" id="apidoc.module.algorithms.DataStructures.AVLTree.prototype">module algorithms.DataStructures.AVLTree.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.AVLTree.prototype._find" id="apidoc.element.algorithms.DataStructures.AVLTree.prototype._find">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.AVLTree.prototype.</span>_find
        <span class="apidocSignatureSpan">(value, current)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_find = function (value, current) {
  if (!current) {
    return null;
  }

  var node;
  if (current.value === value) {
    node = current;
  } else if (current.value &gt; value) {
    node = this._find(value, current.left);
  } else if (current.value &lt; value) {
    node = this._find(value, current.right);
  }

  return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.preOrder(current.right, callback);
};

/**
 * Finds a node by its value.
 */
AVLTree.prototype.find = function (value) {
return this.<span class="apidocCodeKeywordSpan">_find</span>(value, this.root);
};

/**
 * Finds a node by its value in the given sub-tree.
 */
AVLTree.prototype._find = function (value, current) {
if (!current) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.AVLTree.prototype._findMax" id="apidoc.element.algorithms.DataStructures.AVLTree.prototype._findMax">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.AVLTree.prototype.</span>_findMax
        <span class="apidocSignatureSpan">(node, current)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_findMax = function (node, current) {
  current = current || {
    value: -Infinity
  };
  if (!node) {
    return current;
  }
  if (current.value &lt; node.value) {
    current = node;
  }
  return this._findMax(node.right, current);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};
if (!node) {
  return current;
}
if (current.value &lt; node.value) {
  current = node;
}
return this.<span class="apidocCodeKeywordSpan">_findMax</span>(node.right, current);
};

/**
 * Finds the node with minimum value in the whole tree.
 */
AVLTree.prototype.findMin = function () {
return this._findMin(this.root);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.AVLTree.prototype._findMin" id="apidoc.element.algorithms.DataStructures.AVLTree.prototype._findMin">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.AVLTree.prototype.</span>_findMin
        <span class="apidocSignatureSpan">(node, current)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_findMin = function (node, current) {
  current = current || {
    value: Infinity
  };
  if (!node) {
    return current;
  }
  if (current.value &gt; node.value) {
    current = node;
  }
  return this._findMin(node.left, current);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  };
  if (!node) {
    return current;
  }
  if (current.value &gt; node.value) {
    current = node;
  }
  return this.<span class="apidocCodeKeywordSpan">_findMin</span>(node.left, current);
};

/**
 * Finds the node with maximum value in the given
 * sub-tree.
 */
AVLTree.prototype._findMax = function (node, current) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.AVLTree.prototype.find" id="apidoc.element.algorithms.DataStructures.AVLTree.prototype.find">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.AVLTree.prototype.</span>find
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">find = function (value) {
  return this._find(value, this.root);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
};

/**
 * Removes a node by its value.
 */
AVLTree.prototype.remove = function (value) {
var node = this.<span class="apidocCodeKeywordSpan">find</span>(value);
if (!node) {
  return false;
}

if (node.left &amp;&amp; node.right) {
  var min = this.findMin(node.right);
  var temp = node.value;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.AVLTree.prototype.findMax" id="apidoc.element.algorithms.DataStructures.AVLTree.prototype.findMax">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.AVLTree.prototype.</span>findMax
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findMax = function () {
  return this._findMax(this.root);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.AVLTree.prototype.findMin" id="apidoc.element.algorithms.DataStructures.AVLTree.prototype.findMin">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.AVLTree.prototype.</span>findMin
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findMin = function () {
  return this._findMin(this.root);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
AVLTree.prototype.remove = function (value) {
var node = this.find(value);
if (!node) {
  return false;
}

if (node.left &amp;&amp; node.right) {
  var min = this.<span class="apidocCodeKeywordSpan">findMin</span>(node.right);
  var temp = node.value;
  node.value = min.value;
  min.value = temp;
  return this.remove(min);
} else if (node.left) {
  this.replaceChild(node.parent, node, node.left);
  this.keepHeightBalance(node.left, true);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.AVLTree.prototype.getNodeHeight" id="apidoc.element.algorithms.DataStructures.AVLTree.prototype.getNodeHeight">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.AVLTree.prototype.</span>getNodeHeight
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getNodeHeight = function (node) {
  var height = 1;
  if (node.left !== null &amp;&amp; node.right !== null) {
    height = Math.max(node.left.height, node.right.height) + 1;
  } else if (node.left !== null) {
    height = node.left.height + 1;
  } else if (node.right !== null) {
    height = node.right.height + 1;
  }
  return height;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * root and checking for invalid heights.
 */
AVLTree.prototype.keepHeightBalance = function (node, afterRemove) {
var current = node;
var traveledNodes = [];
while (current !== null) {
  traveledNodes.push(current);
  current.height = this.<span class="apidocCodeKeywordSpan">getNodeHeight</span>(current);
  if (!this.isNodeBalanced(current)) {
    var nodesToBeRestructured = (afterRemove) ?
      this.getNodesToRestructureAfterRemove(traveledNodes) :
      this.getNodesToRestructureAfterInsert(traveledNodes);
    this.restructure(nodesToBeRestructured);
  }
  current = current.parent;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.AVLTree.prototype.getNodesToRestructureAfterInsert" id="apidoc.element.algorithms.DataStructures.AVLTree.prototype.getNodesToRestructureAfterInsert">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.AVLTree.prototype.</span>getNodesToRestructureAfterInsert
        <span class="apidocSignatureSpan">(traveledNodes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getNodesToRestructureAfterInsert = function (traveledNodes) {
  // z is last traveled node - imbalance found at z
  var zIndex = traveledNodes.length - 1;
  var z = traveledNodes[zIndex];

  // y should be child of z with larger height
  // (must be ancestor of inserted node)
  // therefore, last traveled node is correct.
  var yIndex = traveledNodes.length - 2;
  var y = traveledNodes[yIndex];

  // x should be tallest child of y
  // If children same height, x should be ancestor
  // of inserted node (in traveled path)
  var x;
  if (y.left !== null &amp;&amp; y.right !== null) {
    if (y.left.height &gt; y.right.height) {
      x = y.left;
    } else if (y.left.height &lt; y.right.height) {
      x = y.right;
    } else if (y.left.height === y.right.height) {
      var xIndex = traveledNodes.length - 3;
      x = traveledNodes[xIndex];
    }
  } else if (y.left !== null &amp;&amp; y.right === null) {
    x = y.left;
  } else if (y.right !== null &amp;&amp; y.left === null) {
    x = y.right;
  }
  return [x, y, z];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var traveledNodes = [];
  while (current !== null) {
    traveledNodes.push(current);
    current.height = this.getNodeHeight(current);
    if (!this.isNodeBalanced(current)) {
      var nodesToBeRestructured = (afterRemove) ?
        this.getNodesToRestructureAfterRemove(traveledNodes) :
        this.<span class="apidocCodeKeywordSpan">getNodesToRestructureAfterInsert</span>(traveledNodes);
      this.restructure(nodesToBeRestructured);
    }
    current = current.parent;
  }
};

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.AVLTree.prototype.getNodesToRestructureAfterRemove" id="apidoc.element.algorithms.DataStructures.AVLTree.prototype.getNodesToRestructureAfterRemove">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.AVLTree.prototype.</span>getNodesToRestructureAfterRemove
        <span class="apidocSignatureSpan">(traveledNodes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getNodesToRestructureAfterRemove = function (traveledNodes) {
  // z is last traveled node - imbalance found at z
  var zIndex = traveledNodes.length - 1;
  var z = traveledNodes[zIndex];

  // y should be child of z with larger height
  // (cannot be ancestor of removed node)
  var y;
  if (z.left !== null &amp;&amp; z.right !== null) {
    y = (z.left === y) ? z.right : z.left;
  } else if (z.left !== null &amp;&amp; z.right === null) {
    y = z.left;
  } else if (z.right !== null &amp;&amp; z.left === null) {
    y = z.right;
  }

  // x should be tallest child of y
  // If children same height, x should be child of y
  // that has same orientation as z to y
  var x;
  if (y.left !== null &amp;&amp; y.right !== null) {
    if (y.left.height &gt; y.right.height) {
      x = y.left;
    } else if (y.left.height &lt; y.right.height) {
      x = y.right;
    } else if (y.left.height === y.right.height) {
      x = (z.left === y) ? y.left : y.right;
    }
  } else if (y.left !== null &amp;&amp; y.right === null) {
    x = y.left;
  } else if (y.right !== null &amp;&amp; y.left === null) {
    x = y.right;
  }
  return [x, y, z];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var current = node;
  var traveledNodes = [];
  while (current !== null) {
    traveledNodes.push(current);
    current.height = this.getNodeHeight(current);
    if (!this.isNodeBalanced(current)) {
      var nodesToBeRestructured = (afterRemove) ?
        this.<span class="apidocCodeKeywordSpan">getNodesToRestructureAfterRemove</span>(traveledNodes) :
        this.getNodesToRestructureAfterInsert(traveledNodes);
      this.restructure(nodesToBeRestructured);
    }
    current = current.parent;
  }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.AVLTree.prototype.getTreeHeight" id="apidoc.element.algorithms.DataStructures.AVLTree.prototype.getTreeHeight">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.AVLTree.prototype.</span>getTreeHeight
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getTreeHeight = function () {
  var current = this.root;

  if (!current) {
    return 0;
  }
  return 1 + Math.max(this.getNodeHeight(current._left),
    this._getNodeHeight(current._right));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.AVLTree.prototype.inOrder" id="apidoc.element.algorithms.DataStructures.AVLTree.prototype.inOrder">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.AVLTree.prototype.</span>inOrder
        <span class="apidocSignatureSpan">(current, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inOrder = function (current, callback) {
  if (!current) {
    return;
  }
  this.inOrder(current.left, callback);
  if (typeof callback === 'function') {
    callback(current);
  }
  this.inOrder(current.right, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
 * In-order traversal from the given node.
 */
AVLTree.prototype.inOrder = function (current, callback) {
  if (!current) {
    return;
  }
  this.<span class="apidocCodeKeywordSpan">inOrder</span>(current.left, callback);
  if (typeof callback === 'function') {
    callback(current);
  }
  this.inOrder(current.right, callback);
};

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.AVLTree.prototype.insert" id="apidoc.element.algorithms.DataStructures.AVLTree.prototype.insert">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.AVLTree.prototype.</span>insert
        <span class="apidocSignatureSpan">(value, current)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">insert = function (value, current) {
  if (this.root === null) {
    this.root = new Node(value, null, null, null, 1);
    this.keepHeightBalance(this.root);
    return;
  }

  var insertKey;
  current = current || this.root;
  if (current.value &gt; value) {
    insertKey = 'left';
  } else {
    insertKey = 'right';
  }

  if (!current[insertKey]) {
    current[insertKey] = new Node(value, null, null, current);
    this.keepHeightBalance(current[insertKey], false);
  } else {
    this.insert(value, current[insertKey]);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    insertKey = 'right';
  }

  if (!current[insertKey]) {
    current[insertKey] = new Node(value, null, null, current);
    this.keepHeightBalance(current[insertKey], false);
  } else {
    this.<span class="apidocCodeKeywordSpan">insert</span>(value, current[insertKey]);
  }
};

/**
 * In-order traversal from the given node.
 */
AVLTree.prototype.inOrder = function (current, callback) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.AVLTree.prototype.isNodeBalanced" id="apidoc.element.algorithms.DataStructures.AVLTree.prototype.isNodeBalanced">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.AVLTree.prototype.</span>isNodeBalanced
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isNodeBalanced = function (node) {
  var isBalanced = true;

  if (node.left !== null &amp;&amp; node.right !== null) {
    isBalanced = (Math.abs(node.left.height - node.right.height) &lt;= 1);
  } else if (node.right !== null &amp;&amp; node.left === null) {
    isBalanced = node.right.height &lt; 2;
  } else if (node.left !== null &amp;&amp; node.right === null) {
    isBalanced = node.left.height &lt; 2;
  }
  return isBalanced;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
AVLTree.prototype.keepHeightBalance = function (node, afterRemove) {
var current = node;
var traveledNodes = [];
while (current !== null) {
  traveledNodes.push(current);
  current.height = this.getNodeHeight(current);
  if (!this.<span class="apidocCodeKeywordSpan">isNodeBalanced</span>(current)) {
    var nodesToBeRestructured = (afterRemove) ?
      this.getNodesToRestructureAfterRemove(traveledNodes) :
      this.getNodesToRestructureAfterInsert(traveledNodes);
    this.restructure(nodesToBeRestructured);
  }
  current = current.parent;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.AVLTree.prototype.isTreeBalanced" id="apidoc.element.algorithms.DataStructures.AVLTree.prototype.isTreeBalanced">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.AVLTree.prototype.</span>isTreeBalanced
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isTreeBalanced = function () {
  var current = this.root;

  if (!current) {
    return true;
  }
  return this._isBalanced(current._left) &amp;&amp;
    this._isBalanced(current._right) &amp;&amp;
    Math.abs(this._getNodeHeight(current._left) -
      this._getNodeHeight(current._right)) &lt;= 1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.AVLTree.prototype.keepHeightBalance" id="apidoc.element.algorithms.DataStructures.AVLTree.prototype.keepHeightBalance">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.AVLTree.prototype.</span>keepHeightBalance
        <span class="apidocSignatureSpan">(node, afterRemove)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">keepHeightBalance = function (node, afterRemove) {
  var current = node;
  var traveledNodes = [];
  while (current !== null) {
    traveledNodes.push(current);
    current.height = this.getNodeHeight(current);
    if (!this.isNodeBalanced(current)) {
      var nodesToBeRestructured = (afterRemove) ?
        this.getNodesToRestructureAfterRemove(traveledNodes) :
        this.getNodesToRestructureAfterInsert(traveledNodes);
      this.restructure(nodesToBeRestructured);
    }
    current = current.parent;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
 * Inserts a value as a Node of an AVL Tree.
 */
AVLTree.prototype.insert = function (value, current) {
if (this.root === null) {
  this.root = new Node(value, null, null, null, 1);
  this.<span class="apidocCodeKeywordSpan">keepHeightBalance</span>(this.root);
  return;
}

var insertKey;
current = current || this.root;
if (current.value &gt; value) {
  insertKey = 'left';
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.AVLTree.prototype.leftLeft" id="apidoc.element.algorithms.DataStructures.AVLTree.prototype.leftLeft">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.AVLTree.prototype.</span>leftLeft
        <span class="apidocSignatureSpan">(x, y, z)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">leftLeft = function (x, y, z) {
  //pass z parent to y and move y's right to z's left
  if (z.parent !== null) {
    var orientation = (z.parent.left === z) ? 'left' : 'right';
    z.parent[orientation] = y;
    y.parent = z.parent;
  } else {
    this.root = y;
    y.parent = null;
  }

  z.left = y.right;
  if (z.left !== null) {
    z.left.parent = z;
  }
  //fix y right child
  y.right = z;
  z.parent = y;

  // Correct each nodes height - order matters, children first
  x.height = this.getNodeHeight(x);
  z.height = this.getNodeHeight(z);
  y.height = this.getNodeHeight(y);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var y = nodesToRestructure[1];
  var z = nodesToRestructure[2];

  // Determine Rotation Pattern
  if (z.right === y &amp;&amp; y.right === x) {
    this.rightRight(x, y, z);
  } else if (z.left === y &amp;&amp; y.left === x) {
    this.<span class="apidocCodeKeywordSpan">leftLeft</span>(x, y, z);
  } else if (z.right === y &amp;&amp; y.left === x) {
    this.rightLeft(x, y, z);
  } else if (z.left === y &amp;&amp; y.right === x) {
    this.leftRight(x, y, z);
  }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.AVLTree.prototype.leftRight" id="apidoc.element.algorithms.DataStructures.AVLTree.prototype.leftRight">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.AVLTree.prototype.</span>leftRight
        <span class="apidocSignatureSpan">(x, y, z)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">leftRight = function (x, y, z) {
  //pass z parent to x
  if (z.parent !== null) {
    var orientation = (z.parent.left === z) ? 'left' : 'right';
    z.parent[orientation] = x;
    x.parent = z.parent;
  } else {
    this.root = x;
    x.parent = null;
  }

  // Adoptions
  z.left = x.right;
  if (z.left !== null) {
    z.left.parent = z;
  }
  y.right = x.left;
  if (y.right !== null) {
    y.right.parent = y;
  }

  // Point to new children (x new parent)
  x.right = z;
  x.left = y;
  x.left.parent = x;
  x.right.parent = x;

  // Correct each nodes height - order matters, children first
  y.height = this.getNodeHeight(y);
  z.height = this.getNodeHeight(z);
  x.height = this.getNodeHeight(x);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (z.right === y &amp;&amp; y.right === x) {
    this.rightRight(x, y, z);
  } else if (z.left === y &amp;&amp; y.left === x) {
    this.leftLeft(x, y, z);
  } else if (z.right === y &amp;&amp; y.left === x) {
    this.rightLeft(x, y, z);
  } else if (z.left === y &amp;&amp; y.right === x) {
    this.<span class="apidocCodeKeywordSpan">leftRight</span>(x, y, z);
  }
};

/**
 * Right-right rotation pattern.
 */
AVLTree.prototype.rightRight = function (x, y, z) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.AVLTree.prototype.postOrder" id="apidoc.element.algorithms.DataStructures.AVLTree.prototype.postOrder">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.AVLTree.prototype.</span>postOrder
        <span class="apidocSignatureSpan">(current, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">postOrder = function (current, callback) {
  if (!current) {
    return;
  }

  this.postOrder(current.left, callback);
  this.postOrder(current.right, callback);
  if (typeof callback === 'function') {
    callback(current);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Post-order traversal from the given node.
 */
AVLTree.prototype.postOrder = function (current, callback) {
  if (!current) {
    return;
  }

  this.<span class="apidocCodeKeywordSpan">postOrder</span>(current.left, callback);
  this.postOrder(current.right, callback);
  if (typeof callback === 'function') {
    callback(current);
  }
};

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.AVLTree.prototype.preOrder" id="apidoc.element.algorithms.DataStructures.AVLTree.prototype.preOrder">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.AVLTree.prototype.</span>preOrder
        <span class="apidocSignatureSpan">(current, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">preOrder = function (current, callback) {
  if (!current) {
    return;
  }
  if (typeof callback === 'function') {
    callback(current);
  }
  this.preOrder(current.left, callback);
  this.preOrder(current.right, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
AVLTree.prototype.preOrder = function (current, callback) {
  if (!current) {
    return;
  }
  if (typeof callback === 'function') {
    callback(current);
  }
  this.<span class="apidocCodeKeywordSpan">preOrder</span>(current.left, callback);
  this.preOrder(current.right, callback);
};

/**
 * Finds a node by its value.
 */
AVLTree.prototype.find = function (value) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.AVLTree.prototype.remove" id="apidoc.element.algorithms.DataStructures.AVLTree.prototype.remove">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.AVLTree.prototype.</span>remove
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">remove = function (value) {
  var node = this.find(value);
  if (!node) {
    return false;
  }

  if (node.left &amp;&amp; node.right) {
    var min = this.findMin(node.right);
    var temp = node.value;
    node.value = min.value;
    min.value = temp;
    return this.remove(min);
  } else if (node.left) {
    this.replaceChild(node.parent, node, node.left);
    this.keepHeightBalance(node.left, true);
  } else if (node.right) {
    this.replaceChild(node.parent, node, node.right);
    this.keepHeightBalance(node.right, true);
  } else {
    this.replaceChild(node.parent, node, null);
    this.keepHeightBalance(node.parent, true);
  }
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

if (node.left &amp;&amp; node.right) {
  var min = this.findMin(node.right);
  var temp = node.value;
  node.value = min.value;
  min.value = temp;
  return this.<span class="apidocCodeKeywordSpan">remove</span>(min);
} else if (node.left) {
  this.replaceChild(node.parent, node, node.left);
  this.keepHeightBalance(node.left, true);
} else if (node.right) {
  this.replaceChild(node.parent, node, node.right);
  this.keepHeightBalance(node.right, true);
} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.AVLTree.prototype.replaceChild" id="apidoc.element.algorithms.DataStructures.AVLTree.prototype.replaceChild">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.AVLTree.prototype.</span>replaceChild
        <span class="apidocSignatureSpan">(parent, oldChild, newChild)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">replaceChild = function (parent, oldChild, newChild) {
  if (parent === null) {
    this.root = newChild;
    if (this.root !== null) {
      this.root.parent = null;
    }
  } else {
    if (parent.left === oldChild) {
      parent.left = newChild;
    } else {
      parent.right = newChild;
    }
    if (newChild) {
      newChild.parent = parent;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (node.left &amp;&amp; node.right) {
  var min = this.findMin(node.right);
  var temp = node.value;
  node.value = min.value;
  min.value = temp;
  return this.remove(min);
} else if (node.left) {
  this.<span class="apidocCodeKeywordSpan">replaceChild</span>(node.parent, node, node.left);
  this.keepHeightBalance(node.left, true);
} else if (node.right) {
  this.replaceChild(node.parent, node, node.right);
  this.keepHeightBalance(node.right, true);
} else {
  this.replaceChild(node.parent, node, null);
  this.keepHeightBalance(node.parent, true);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.AVLTree.prototype.restructure" id="apidoc.element.algorithms.DataStructures.AVLTree.prototype.restructure">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.AVLTree.prototype.</span>restructure
        <span class="apidocSignatureSpan">(nodesToRestructure)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">restructure = function (nodesToRestructure) {
  var x = nodesToRestructure[0];
  var y = nodesToRestructure[1];
  var z = nodesToRestructure[2];

  // Determine Rotation Pattern
  if (z.right === y &amp;&amp; y.right === x) {
    this.rightRight(x, y, z);
  } else if (z.left === y &amp;&amp; y.left === x) {
    this.leftLeft(x, y, z);
  } else if (z.right === y &amp;&amp; y.left === x) {
    this.rightLeft(x, y, z);
  } else if (z.left === y &amp;&amp; y.right === x) {
    this.leftRight(x, y, z);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 while (current !== null) {
   traveledNodes.push(current);
   current.height = this.getNodeHeight(current);
   if (!this.isNodeBalanced(current)) {
     var nodesToBeRestructured = (afterRemove) ?
       this.getNodesToRestructureAfterRemove(traveledNodes) :
       this.getNodesToRestructureAfterInsert(traveledNodes);
     this.<span class="apidocCodeKeywordSpan">restructure</span>(nodesToBeRestructured);
   }
   current = current.parent;
 }
};

/**
* Identifies and calls the appropriate pattern
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.AVLTree.prototype.rightLeft" id="apidoc.element.algorithms.DataStructures.AVLTree.prototype.rightLeft">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.AVLTree.prototype.</span>rightLeft
        <span class="apidocSignatureSpan">(x, y, z)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rightLeft = function (x, y, z) {
  //pass z parent to x
  if (z.parent !== null) {
    var orientation = (z.parent.left === z) ? 'left' : 'right';
    z.parent[orientation] = x;
    x.parent = z.parent;
  } else {
    this.root = x;
    x.parent = null;
  }

  // Adoptions
  z.right = x.left;
  if (z.right !== null) {
    z.right.parent = z;
  }
  y.left = x.right;
  if (y.left !== null) {
    y.left.parent = y;
  }

  // Point to new children (x new parent)
  x.left = z;
  x.right = y;
  x.left.parent = x;
  x.right.parent = x;

  // Correct each nodes height - order matters, children first
  y.height = this.getNodeHeight(y);
  z.height = this.getNodeHeight(z);
  x.height = this.getNodeHeight(x);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

 // Determine Rotation Pattern
 if (z.right === y &amp;&amp; y.right === x) {
   this.rightRight(x, y, z);
 } else if (z.left === y &amp;&amp; y.left === x) {
   this.leftLeft(x, y, z);
 } else if (z.right === y &amp;&amp; y.left === x) {
   this.<span class="apidocCodeKeywordSpan">rightLeft</span>(x, y, z);
 } else if (z.left === y &amp;&amp; y.right === x) {
   this.leftRight(x, y, z);
 }
};

/**
* Right-right rotation pattern.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.AVLTree.prototype.rightRight" id="apidoc.element.algorithms.DataStructures.AVLTree.prototype.rightRight">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.AVLTree.prototype.</span>rightRight
        <span class="apidocSignatureSpan">(x, y, z)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rightRight = function (x, y, z) {
  // pass z parent to y and move y's left to z's right
  if (z.parent !== null) {
    var orientation = (z.parent.left === z) ? 'left' : 'right';
    z.parent[orientation] = y;
    y.parent = z.parent;
  } else {
    this.root = y;
    y.parent = null;
  }

  // z adopts y's left.
  z.right = y.left;
  if (z.right !== null) {
    z.right.parent = z;
  }
  // y adopts z
  y.left = z;
  z.parent = y;

  // Correct each nodes height - order matters, children first
  x.height = this.getNodeHeight(x);
  z.height = this.getNodeHeight(z);
  y.height = this.getNodeHeight(y);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
AVLTree.prototype.restructure = function (nodesToRestructure) {
var x = nodesToRestructure[0];
var y = nodesToRestructure[1];
var z = nodesToRestructure[2];

// Determine Rotation Pattern
if (z.right === y &amp;&amp; y.right === x) {
  this.<span class="apidocCodeKeywordSpan">rightRight</span>(x, y, z);
} else if (z.left === y &amp;&amp; y.left === x) {
  this.leftLeft(x, y, z);
} else if (z.right === y &amp;&amp; y.left === x) {
  this.rightLeft(x, y, z);
} else if (z.left === y &amp;&amp; y.right === x) {
  this.leftRight(x, y, z);
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.algorithms.DataStructures.BST" id="apidoc.module.algorithms.DataStructures.BST">module algorithms.DataStructures.BST</a></h1>


    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.BST.BST" id="apidoc.element.algorithms.DataStructures.BST.BST">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.</span>BST
        <span class="apidocSignatureSpan">(compareFn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BST(compareFn) {
  this.root = null;
  this._size = 0;
<span class="apidocCodeCommentSpan">  /**
   * @var Comparator
   */
</span>  this._comparator = new Comparator(compareFn);

  /**
   * Read-only property for the size of the tree
   */
  Object.defineProperty(this, 'size', {
    get: function () { return this._size; }.bind(this)
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.algorithms.DataStructures.BST.prototype" id="apidoc.module.algorithms.DataStructures.BST.prototype">module algorithms.DataStructures.BST.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.BST.prototype._find" id="apidoc.element.algorithms.DataStructures.BST.prototype._find">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.BST.prototype.</span>_find
        <span class="apidocSignatureSpan">(e, root)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_find = function (e, root) {

  if (!root) {
    if (this.root) root = this.root;
    else return false;
  }

  if (root.value === e)
    return root;

  if (this._comparator.lessThan(e, root.value))
    return root.left &amp;&amp; this._find(e, root.left);

  if (this._comparator.greaterThan(e, root.value))
    return root.right &amp;&amp; this._find(e, root.right);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.preOrder(current.right, callback);
};

/**
 * Finds a node by its value.
 */
AVLTree.prototype.find = function (value) {
return this.<span class="apidocCodeKeywordSpan">_find</span>(value, this.root);
};

/**
 * Finds a node by its value in the given sub-tree.
 */
AVLTree.prototype._find = function (value, current) {
if (!current) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.BST.prototype._findMin" id="apidoc.element.algorithms.DataStructures.BST.prototype._findMin">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.BST.prototype.</span>_findMin
        <span class="apidocSignatureSpan">(root)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_findMin = function (root) {
  var minNode = root;
  while (minNode.left) {
    minNode = minNode.left;
  }
  return minNode;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  };
  if (!node) {
    return current;
  }
  if (current.value &gt; node.value) {
    current = node;
  }
  return this.<span class="apidocCodeKeywordSpan">_findMin</span>(node.left, current);
};

/**
 * Finds the node with maximum value in the given
 * sub-tree.
 */
AVLTree.prototype._findMax = function (node, current) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.BST.prototype._replaceNodeInParent" id="apidoc.element.algorithms.DataStructures.BST.prototype._replaceNodeInParent">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.BST.prototype.</span>_replaceNodeInParent
        <span class="apidocSignatureSpan">(currNode, newNode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_replaceNodeInParent = function (currNode, newNode) {
  var parent = currNode.parent;
  if (parent) {
    parent[currNode === parent.left ? 'left' : 'right'] = newNode;
    if (newNode)
      newNode.parent = parent;
  } else {
    this.root = newNode;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    node.value = successor.value;
  } else {
    /**
     * If the node is a leaf, just make the parent point to null,
     * and if it has one child, make the parent point to this child
     * instead
     */
    this.<span class="apidocCodeKeywordSpan">_replaceNodeInParent</span>(node, node.left || node.right);
    this._size--;
  }
};

module.exports = BST;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.BST.prototype.contains" id="apidoc.element.algorithms.DataStructures.BST.prototype.contains">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.BST.prototype.</span>contains
        <span class="apidocSignatureSpan">(e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">contains = function (e) {
  return !!this._find(e);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Normalize vertex labels as strings
var _ = function (v) {
  return '' + v;
};

Graph.prototype.addVertex = function (v) {
  v = _(v);
  if (this.vertices.<span class="apidocCodeKeywordSpan">contains</span>(v)) {
    throw new Error('Vertex "' + v + '" has already been added');
  }
  this.vertices.add(v);
  this.adjList[v] = Object.create(null);
};

Graph.prototype.addEdge = function (a, b, w) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.BST.prototype.insert" id="apidoc.element.algorithms.DataStructures.BST.prototype.insert">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.BST.prototype.</span>insert
        <span class="apidocSignatureSpan">(value, parent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">insert = function (value, parent) {
  // Set the root as the initial insertion point
  // if it has not been passed
  if (!parent) {
    if (!this.root) {
      this.root = new Node(value);
      this._size++;
      return;
    }
    parent = this.root;
  }

  var child = this._comparator.lessThan(value, parent.value) ? 'left' : 'right';
  if (parent[child]) {
    this.insert(value, parent[child]);
  } else {
    parent[child] = new Node(value, parent);
    this._size++;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    insertKey = 'right';
  }

  if (!current[insertKey]) {
    current[insertKey] = new Node(value, null, null, current);
    this.keepHeightBalance(current[insertKey], false);
  } else {
    this.<span class="apidocCodeKeywordSpan">insert</span>(value, current[insertKey]);
  }
};

/**
 * In-order traversal from the given node.
 */
AVLTree.prototype.inOrder = function (current, callback) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.BST.prototype.remove" id="apidoc.element.algorithms.DataStructures.BST.prototype.remove">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.BST.prototype.</span>remove
        <span class="apidocSignatureSpan">(e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">remove = function (e) {
  var node = this._find(e);
  if (!node) {
    throw new Error('Item not found in the tree');
  }

  if (node.left &amp;&amp; node.right) {
<span class="apidocCodeCommentSpan">    /**
     * If the node to be removed has both left and right children,
     * replace the node's value by the minimum value of the right
     * sub-tree, and remove the leave containing the value
     */
</span>    var successor = this._findMin(node.right);
    this.remove(successor.value);
    node.value = successor.value;
  } else {
    /**
     * If the node is a leaf, just make the parent point to null,
     * and if it has one child, make the parent point to this child
     * instead
     */
    this._replaceNodeInParent(node, node.left || node.right);
    this._size--;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

if (node.left &amp;&amp; node.right) {
  var min = this.findMin(node.right);
  var temp = node.value;
  node.value = min.value;
  min.value = temp;
  return this.<span class="apidocCodeKeywordSpan">remove</span>(min);
} else if (node.left) {
  this.replaceChild(node.parent, node, node.left);
  this.keepHeightBalance(node.left, true);
} else if (node.right) {
  this.replaceChild(node.parent, node, node.right);
  this.keepHeightBalance(node.right, true);
} else {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.algorithms.DataStructures.DisjointSetForest" id="apidoc.module.algorithms.DataStructures.DisjointSetForest">module algorithms.DataStructures.DisjointSetForest</a></h1>


    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.DisjointSetForest.DisjointSetForest" id="apidoc.element.algorithms.DataStructures.DisjointSetForest.DisjointSetForest">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.</span>DisjointSetForest
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DisjointSetForest() {
  this._parents = {};
  this._ranks = {};
  this._sizes = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.algorithms.DataStructures.DisjointSetForest.prototype" id="apidoc.module.algorithms.DataStructures.DisjointSetForest.prototype">module algorithms.DataStructures.DisjointSetForest.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.DisjointSetForest.prototype._introduce" id="apidoc.element.algorithms.DataStructures.DisjointSetForest.prototype._introduce">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.DisjointSetForest.prototype.</span>_introduce
        <span class="apidocSignatureSpan">(element)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_introduce = function (element) {
  if (!(element in this._parents)) {
    this._parents[element] = element;
    this._ranks[element] = 0;
    this._sizes[element] = 1;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Check if the elements belong to the same subset.
 * Complexity: O(A^-1) (inverse Ackermann function) amortized.
 *
 * @param {...*} element
 * @return {boolean}
 */
DisjointSetForest.prototype.sameSubset = function (element) {
  this.<span class="apidocCodeKeywordSpan">_introduce</span>(element);
  var root = this.root(element);
  return [].slice.call(arguments, 1).every(function (element) {
    this._introduce(element);
    return this.root(element) === root;
  }.bind(this));
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.DisjointSetForest.prototype.merge" id="apidoc.element.algorithms.DataStructures.DisjointSetForest.prototype.merge">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.DisjointSetForest.prototype.</span>merge
        <span class="apidocSignatureSpan">(element1, element2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function merge(element1, element2) {
  if (arguments.length &gt; 2) {
    merge.apply(this, [].slice.call(arguments, 1));
  }

  this._introduce(element1);
  this._introduce(element2);
  var root1 = this.root(element1);
  var root2 = this.root(element2);

  if (this._ranks[root1] &lt; this._ranks[root2]) {
    this._parents[root1] = root2;
    this._sizes[root2] += this._sizes[root1];
  }
  else if (root1 !== root2) {
    this._parents[root2] = root1;
    this._sizes[root1] += this._sizes[root2];
    if (this._ranks[root1] === this._ranks[root2]) {
      this._ranks[root1] += 1;
    }
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  });

  edges.sort(function (a, b) {
    return a.weight - b.weight;
  }).forEach(function (edge) {
    if (!connectedComponents.sameSubset(edge.ends[0], edge.ends[1])) {
      mst.addEdge(edge.ends[0], edge.ends[1], edge.weight);
      connectedComponents.<span class="apidocCodeKeywordSpan">merge</span>(edge.ends[0], edge.ends[1]);
    }
  });

  return mst;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.DisjointSetForest.prototype.root" id="apidoc.element.algorithms.DataStructures.DisjointSetForest.prototype.root">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.DisjointSetForest.prototype.</span>root
        <span class="apidocSignatureSpan">(element)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">root = function (element) {
  this._introduce(element);
  if (this._parents[element] !== element) {
    this._parents[element] = this.root(this._parents[element]);
  }
  return this._parents[element];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Complexity: O(A^-1) (inverse Ackermann function) amortized.
 *
 * @param {...*} element
 * @return {boolean}
 */
DisjointSetForest.prototype.sameSubset = function (element) {
  this._introduce(element);
  var root = this.<span class="apidocCodeKeywordSpan">root</span>(element);
  return [].slice.call(arguments, 1).every(function (element) {
    this._introduce(element);
    return this.root(element) === root;
  }.bind(this));
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.DisjointSetForest.prototype.sameSubset" id="apidoc.element.algorithms.DataStructures.DisjointSetForest.prototype.sameSubset">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.DisjointSetForest.prototype.</span>sameSubset
        <span class="apidocSignatureSpan">(element)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sameSubset = function (element) {
  this._introduce(element);
  var root = this.root(element);
  return [].slice.call(arguments, 1).every(function (element) {
    this._introduce(element);
    return this.root(element) === root;
  }.bind(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      }
    });
  });

  edges.sort(function (a, b) {
    return a.weight - b.weight;
  }).forEach(function (edge) {
    if (!connectedComponents.<span class="apidocCodeKeywordSpan">sameSubset</span>(edge.ends[0], edge.ends[1])) {
      mst.addEdge(edge.ends[0], edge.ends[1], edge.weight);
      connectedComponents.merge(edge.ends[0], edge.ends[1]);
    }
  });

  return mst;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.DisjointSetForest.prototype.size" id="apidoc.element.algorithms.DataStructures.DisjointSetForest.prototype.size">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.DisjointSetForest.prototype.</span>size
        <span class="apidocSignatureSpan">(element)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">size = function (element) {
  this._introduce(element);
  return this._sizes[this.root(element)];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      assert(!forest.sameSubset(1, 5));
    });

it('should maintain subset sizes', function () {
  var forest = new DisjointSetForest();
  var assertSizesCorrect = function (elements, size) {
    elements.forEach(function (element) {
      assert.equal(forest.<span class="apidocCodeKeywordSpan">size</span>(element), size);
    });
  };
  assertSizesCorrect([0, 1, 2, 3, 4], 1);
  forest.merge(0, 1);
  assertSizesCorrect([0, 1], 2);
  forest.merge(0, 2);
  assertSizesCorrect([0, 1, 2], 3);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.algorithms.DataStructures.FenwickTree" id="apidoc.module.algorithms.DataStructures.FenwickTree">module algorithms.DataStructures.FenwickTree</a></h1>


    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.FenwickTree.FenwickTree" id="apidoc.element.algorithms.DataStructures.FenwickTree.FenwickTree">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.</span>FenwickTree
        <span class="apidocSignatureSpan">(length)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function FenwickTree(length) {
  this._elements = new Array(length + 1);
  for (var i = 0; i &lt; this._elements.length ; i++)
    this._elements[i] = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.algorithms.DataStructures.FenwickTree.prototype" id="apidoc.module.algorithms.DataStructures.FenwickTree.prototype">module algorithms.DataStructures.FenwickTree.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.FenwickTree.prototype.adjust" id="apidoc.element.algorithms.DataStructures.FenwickTree.prototype.adjust">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.FenwickTree.prototype.</span>adjust
        <span class="apidocSignatureSpan">(index, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">adjust = function (index, value) {
<span class="apidocCodeCommentSpan">  /*
    This function goes up the tree adding the value to all parent nodes.

    In the array, to know where a index is in the tree, just look at where is
    the rightmost bit. 1 is a leaf, because the rightmost bit is at position 0.
    2 (10) is 1 level above the leafs. 4 (100) is 2 levels above the leafs.

    Going up the tree means pushing the rightmost bit far to the left. We do
    this by adding only the bit itself to the index. Eventually we skip
    some levels that aren't represented in the array. E.g. starting at 3 (11),
    it's imediate parent is 11b + 1b = 100b. We started at a leaf  and skipped
    the level-1 node, because it wasn't represented in the array
    (a right child).

    Note: (index&amp;-index) finds the rightmost bit in index.
  */
</span>  for (; index &lt; this._elements.length ; index += (index&amp;-index))
    this._elements[index] += value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var FenwickTree = require('../..').DataStructures.FenwickTree,
assert = require('assert');

describe('FenwickTree', function () {
  it('should allow prefix queries', function () {
var tree = new FenwickTree(10);
tree.<span class="apidocCodeKeywordSpan">adjust</span>(5, 42);
tree.adjust(7, 43);
tree.adjust(9, 44);


assert.equal(tree.prefixSum(0), 0);
assert.equal(tree.prefixSum(1), 0);
assert.equal(tree.prefixSum(2), 0);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.FenwickTree.prototype.prefixSum" id="apidoc.element.algorithms.DataStructures.FenwickTree.prototype.prefixSum">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.FenwickTree.prototype.</span>prefixSum
        <span class="apidocSignatureSpan">(index)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">prefixSum = function (index) {
<span class="apidocCodeCommentSpan">  /*
    This function goes up the tree adding the required nodes to sum the prefix.

    The key here is to sum every node that isn't in the same subtree as an
    already seen node. In practice we proceed always getting a node's uncle
    (the sibling of the node's parent). So, if we start at the index 7, we must
    go to 6 (7's uncle), then to 4 (6's uncle), then we stop, because 4 has
    no uncle.

    Binary-wise, this is the same as erasing the rightmost bit of the index.
    E.g. 7 (111) -&gt; 6 (110) -&gt; 4 (100).

    Note: (index&amp;-index) finds the rightmost bit in index.
  */
</span>
  var sum = 0;
  for (; index &gt; 0 ; index -= (index&amp;-index))
    sum += this._elements[index];
  return sum;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return sum;
};

/**
* Returns the sum of all values between two indexes in O(log n)
*/
FenwickTree.prototype.rangeSum = function (fromIndex, toIndex) {
  return this.<span class="apidocCodeKeywordSpan">prefixSum</span>(toIndex) - this.prefixSum(fromIndex - 1);
};

module.exports = FenwickTree;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.FenwickTree.prototype.rangeSum" id="apidoc.element.algorithms.DataStructures.FenwickTree.prototype.rangeSum">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.FenwickTree.prototype.</span>rangeSum
        <span class="apidocSignatureSpan">(fromIndex, toIndex)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rangeSum = function (fromIndex, toIndex) {
  return this.prefixSum(toIndex) - this.prefixSum(fromIndex - 1);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  it('should allow range queries', function () {
    var tree = new FenwickTree(10);
    tree.adjust(5, 42);
    tree.adjust(7, 43);
    tree.adjust(9, 44);


    assert.equal(tree.<span class="apidocCodeKeywordSpan">rangeSum</span>(6, 10), 43 + 44);
    assert.equal(tree.rangeSum(5, 7), 42 + 43);
  });
});
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.algorithms.DataStructures.Graph" id="apidoc.module.algorithms.DataStructures.Graph">module algorithms.DataStructures.Graph</a></h1>


    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.Graph.Graph" id="apidoc.element.algorithms.DataStructures.Graph.Graph">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.</span>Graph
        <span class="apidocSignatureSpan">(directed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Graph(directed) {
  this.directed = (directed === undefined ? true : !!directed);
  this.adjList = Object.create(null);
  this.vertices = new HashSet();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.algorithms.DataStructures.Graph.prototype" id="apidoc.module.algorithms.DataStructures.Graph.prototype">module algorithms.DataStructures.Graph.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.Graph.prototype.addEdge" id="apidoc.element.algorithms.DataStructures.Graph.prototype.addEdge">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.Graph.prototype.</span>addEdge
        <span class="apidocSignatureSpan">(a, b, w)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addEdge = function (a, b, w) {
  a = _(a);
  b = _(b);
  // If no weight is assigned to the edge, 1 is the default
  w = (w === undefined ? 1 : w);

  if (!this.adjList[a]) this.addVertex(a);
  if (!this.adjList[b]) this.addVertex(b);

  // If there's already another edge with the same origin and destination
  // sum with the current one
  this.adjList[a][b] = (this.adjList[a][b] || 0) + w;

  // If the graph is not directed add the edge in both directions
  if (!this.directed) {
    this.adjList[b][a] = (this.adjList[b][a] || 0) + w;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
graph.vertices.forEach(seen.addVertex.bind(seen));

depthFirstSearch(graph, endpoints.start, {
  allowTraversal: function (vertex, neighbor) {
    return !seen.edge(vertex, neighbor);
  },
  beforeTraversal: function (vertex, neighbor) {
    seen.<span class="apidocCodeKeywordSpan">addEdge</span>(vertex, neighbor);
  },
  afterTraversal: function (vertex) {
    route.push(vertex);
  }
});

graph.vertices.forEach(function (vertex) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.Graph.prototype.addVertex" id="apidoc.element.algorithms.DataStructures.Graph.prototype.addVertex">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.Graph.prototype.</span>addVertex
        <span class="apidocSignatureSpan">(v)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addVertex = function (v) {
  v = _(v);
  if (this.vertices.contains(v)) {
    throw new Error('Vertex "' + v + '" has already been added');
  }
  this.vertices.add(v);
  this.adjList[v] = Object.create(null);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Graph.prototype.addEdge = function (a, b, w) {
a = _(a);
b = _(b);
// If no weight is assigned to the edge, 1 is the default
w = (w === undefined ? 1 : w);

if (!this.adjList[a]) this.<span class="apidocCodeKeywordSpan">addVertex</span>(a);
if (!this.adjList[b]) this.addVertex(b);

// If there's already another edge with the same origin and destination
// sum with the current one
this.adjList[a][b] = (this.adjList[a][b] || 0) + w;

// If the graph is not directed add the edge in both directions
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.Graph.prototype.edge" id="apidoc.element.algorithms.DataStructures.Graph.prototype.edge">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.Graph.prototype.</span>edge
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">edge = function (a, b) {
  return this.adjList[_(a)][_(b)];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// Add all the edges from the graph to the 'edges' array
graph.vertices.forEach(function (s) {
  graph.neighbors(s).forEach(function (t) {
    edges.push({
      source: s,
      target: t,
      weight: graph.<span class="apidocCodeKeywordSpan">edge</span>(s, t)
    });
  });

  minDistance[s] = Infinity;
  ++adjacencyListSize;
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.Graph.prototype.neighbors" id="apidoc.element.algorithms.DataStructures.Graph.prototype.neighbors">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.Graph.prototype.</span>neighbors
        <span class="apidocSignatureSpan">(v)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">neighbors = function (v) {
  return Object.keys(this.adjList[_(v)]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var minDistance = {};
var previousVertex = {};
var edges = [];
var adjacencyListSize = 0;

// Add all the edges from the graph to the 'edges' array
graph.vertices.forEach(function (s) {
  graph.<span class="apidocCodeKeywordSpan">neighbors</span>(s).forEach(function (t) {
    edges.push({
      source: s,
      target: t,
      weight: graph.edge(s, t)
    });
  });
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.algorithms.DataStructures.HashTable" id="apidoc.module.algorithms.DataStructures.HashTable">module algorithms.DataStructures.HashTable</a></h1>


    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.HashTable.HashTable" id="apidoc.element.algorithms.DataStructures.HashTable.HashTable">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.</span>HashTable
        <span class="apidocSignatureSpan">(initialCapacity)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function HashTable(initialCapacity) {
  this._table = new Array(initialCapacity || 64);
  this._items = 0;

  Object.defineProperty(this, 'capacity', {
    get: function () {
      return this._table.length;
    }
  });

  Object.defineProperty(this, 'size', {
    get: function () {
      return this._items;
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.algorithms.DataStructures.HashTable.prototype" id="apidoc.module.algorithms.DataStructures.HashTable.prototype">module algorithms.DataStructures.HashTable.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.HashTable.prototype._findInList" id="apidoc.element.algorithms.DataStructures.HashTable.prototype._findInList">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.HashTable.prototype.</span>_findInList
        <span class="apidocSignatureSpan">(list, key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_findInList = function (list, key) {
  var node = list &amp;&amp; list.head;
  while (node) {
    if (node.value.k === key) return node;
    node = node.next;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return hash;
};

HashTable.prototype.get = function (key) {
var i = this._position(key);
var node;
if ((node = this.<span class="apidocCodeKeywordSpan">_findInList</span>(this._table[i], key))) {
  return node.value.v;
}
};

HashTable.prototype.put = function (key, value) {
var i = this._position(key);
if (!this._table[i]) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.HashTable.prototype._increaseCapacity" id="apidoc.element.algorithms.DataStructures.HashTable.prototype._increaseCapacity">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.HashTable.prototype.</span>_increaseCapacity
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_increaseCapacity = function () {
  var oldTable = this._table;
  this._table = new Array(2 * this.capacity);
  this._items = 0;

  for (var i = 0; i &lt; oldTable.length; i++) {
    var node = oldTable[i] &amp;&amp; oldTable[i].head;
    while (node) {
      this.put(node.value.k, node.value.v);
      node = node.next;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // if the key already exists in the list, replace
  // by the current item
  node.value = item;
} else {
  this._table[i].add(item);
  this._items++;

  if (this._items === this.capacity) this.<span class="apidocCodeKeywordSpan">_increaseCapacity</span>();
}
};

HashTable.prototype.del = function (key) {
var i = this._position(key);
var node;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.HashTable.prototype._position" id="apidoc.element.algorithms.DataStructures.HashTable.prototype._position">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.HashTable.prototype.</span>_position
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_position = function (key) {
  return Math.abs(this.hash(key)) % this.capacity;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    hash = ((hash &lt;&lt; 5) - hash) + s.charCodeAt(i);
    hash &amp;= hash; // Keep it a 32bit int
  }
  return hash;
};

HashTable.prototype.get = function (key) {
  var i = this.<span class="apidocCodeKeywordSpan">_position</span>(key);
  var node;
  if ((node = this._findInList(this._table[i], key))) {
    return node.value.v;
  }
};

HashTable.prototype.put = function (key, value) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.HashTable.prototype.del" id="apidoc.element.algorithms.DataStructures.HashTable.prototype.del">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.HashTable.prototype.</span>del
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">del = function (key) {
  var i = this._position(key);
  var node;

  if ((node = this._findInList(this._table[i], key))) {
    this._table[i].delNode(node);
    this._items--;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Pops the element in the beginning of the queue
 */
Queue.prototype.pop = function () {
if (this.isEmpty()) {
  throw new Error('Empty queue');
}
var e = this._elements.get(0);
this._elements.<span class="apidocCodeKeywordSpan">del</span>(0);
return e;
};

Queue.prototype.peek = function () {
if (this.isEmpty()) {
  throw new Error('Empty queue');
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.HashTable.prototype.forEach" id="apidoc.element.algorithms.DataStructures.HashTable.prototype.forEach">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.HashTable.prototype.</span>forEach
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forEach = function (fn) {
  var applyFunction = function (linkedList) {
    linkedList.forEach(function (elem) {
      fn(elem.k, elem.v);
    });
  };

  for (var i = 0; i &lt; this._table.length; i++) {
    if (this._table[i]) {
      applyFunction(this._table[i]);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    node = node.next;
  }
}
};

HashTable.prototype.forEach = function (fn) {
var applyFunction = function (linkedList) {
  linkedList.<span class="apidocCodeKeywordSpan">forEach</span>(function (elem) {
    fn(elem.k, elem.v);
  });
};

for (var i = 0; i &lt; this._table.length; i++) {
  if (this._table[i]) {
    applyFunction(this._table[i]);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.HashTable.prototype.get" id="apidoc.element.algorithms.DataStructures.HashTable.prototype.get">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.HashTable.prototype.</span>get
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get = function (key) {
  var i = this._position(key);
  var node;
  if ((node = this._findInList(this._table[i], key))) {
    return node.value.v;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
 * Pops the element in the beginning of the queue
 */
Queue.prototype.pop = function () {
if (this.isEmpty()) {
  throw new Error('Empty queue');
}
var e = this._elements.<span class="apidocCodeKeywordSpan">get</span>(0);
this._elements.del(0);
return e;
};

Queue.prototype.peek = function () {
if (this.isEmpty()) {
  throw new Error('Empty queue');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.HashTable.prototype.hash" id="apidoc.element.algorithms.DataStructures.HashTable.prototype.hash">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.HashTable.prototype.</span>hash
        <span class="apidocSignatureSpan">(s)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hash = function (s) {
  if (typeof s !== 'string') s = JSON.stringify(s);
  var hash = 0;
  for (var i = 0; i &lt; s.length; i++) {
    hash = ((hash &lt;&lt; 5) - hash) + s.charCodeAt(i);
    hash &amp;= hash; // Keep it a 32bit int
  }
  return hash;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if ((node = this._findInList(this._table[i], key))) {
  this._table[i].delNode(node);
  this._items--;
}
};

HashTable.prototype._position = function (key) {
return Math.abs(this.<span class="apidocCodeKeywordSpan">hash</span>(key)) % this.capacity;
};

HashTable.prototype._findInList = function (list, key) {
var node = list &amp;&amp; list.head;
while (node) {
  if (node.value.k === key) return node;
  node = node.next;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.HashTable.prototype.put" id="apidoc.element.algorithms.DataStructures.HashTable.prototype.put">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.HashTable.prototype.</span>put
        <span class="apidocSignatureSpan">(key, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">put = function (key, value) {
  var i = this._position(key);
  if (!this._table[i]) {
    // Hashing with chaining
    this._table[i] = new LinkedList();
  }
  var item = {k: key, v: value};

  var node = this._findInList(this._table[i], key);
  if (node) {
    // if the key already exists in the list, replace
    // by the current item
    node.value = item;
  } else {
    this._table[i].add(item);
    this._items++;

    if (this._items === this.capacity) this._increaseCapacity();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var oldTable = this._table;
this._table = new Array(2 * this.capacity);
this._items = 0;

for (var i = 0; i &lt; oldTable.length; i++) {
  var node = oldTable[i] &amp;&amp; oldTable[i].head;
  while (node) {
    this.<span class="apidocCodeKeywordSpan">put</span>(node.value.k, node.value.v);
    node = node.next;
  }
}
};

HashTable.prototype.forEach = function (fn) {
var applyFunction = function (linkedList) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.algorithms.DataStructures.Heap" id="apidoc.module.algorithms.DataStructures.Heap">module algorithms.DataStructures.Heap</a></h1>


    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.Heap.MaxHeap" id="apidoc.element.algorithms.DataStructures.Heap.MaxHeap">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.Heap.</span>MaxHeap
        <span class="apidocSignatureSpan">(compareFn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MaxHeap(compareFn) {

  MinHeap.call(this, compareFn);
  this._comparator.reverse();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // Make sure nothing was really removed
  assert.equal(h.n, 6);
});
});

describe('Max Heap', function () {
it('should always return the greatest element', function () {
  var h = new heap.<span class="apidocCodeKeywordSpan">MaxHeap</span>();
  assert(h.isEmpty());
  h.insert(10);
  h.insert(2091);
  h.insert(4);
  h.insert(1);
  h.insert(5);
  h.insert(500);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.Heap.MinHeap" id="apidoc.element.algorithms.DataStructures.Heap.MinHeap">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.Heap.</span>MinHeap
        <span class="apidocSignatureSpan">(compareFn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MinHeap(compareFn) {
  this._elements = [null];
  this._comparator = new Comparator(compareFn);

  Object.defineProperty(this, 'n', {
    get: function () {
      return this._elements.length - 1;
    }.bind(this)
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
'use strict';

var heap = require('../..').DataStructures.Heap,
  assert = require('assert');

describe('Min Heap', function () {
it('should always return the lowest element', function () {
  var h = new heap.<span class="apidocCodeKeywordSpan">MinHeap</span>();
  assert(h.isEmpty());
  h.insert(10);
  h.insert(2091);
  h.insert(4);
  h.insert(1);
  h.insert(5);
  h.insert(500);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.algorithms.DataStructures.Heap.MinHeap.prototype" id="apidoc.module.algorithms.DataStructures.Heap.MinHeap.prototype">module algorithms.DataStructures.Heap.MinHeap.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.Heap.MinHeap.prototype._siftDown" id="apidoc.element.algorithms.DataStructures.Heap.MinHeap.prototype._siftDown">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.Heap.MinHeap.prototype.</span>_siftDown
        <span class="apidocSignatureSpan">(i)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_siftDown = function (i) {
  var c;
  for (i = i || 1; (c = i &lt;&lt; 1) &lt;= this.n; i = c) {
    // checks which is the smaller child to compare with
    if (c + 1 &lt;= this.n &amp;&amp; this._comparator.lessThan(
          this._elements[c + 1], this._elements[c]))
      // use the right child if it's lower than the left one
      c++;
    if (this._comparator.lessThan(this._elements[i],
          this._elements[c]))
      break;
    this._swap(i, c);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 var element = this._elements[1];

 // Get the one from the bottom in insert it on top
 // If this isn't already the last element
 var last = this._elements.pop();
 if (this.n) {
   this._elements[1] = last;
   this.<span class="apidocCodeKeywordSpan">_siftDown</span>();
 }

 return element;
};

/**
* Sift up the last element
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.Heap.MinHeap.prototype._siftUp" id="apidoc.element.algorithms.DataStructures.Heap.MinHeap.prototype._siftUp">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.Heap.MinHeap.prototype.</span>_siftUp
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_siftUp = function () {
  var i, parent;

  for (i = this.n;
      i &gt; 1 &amp;&amp; (parent = i &gt;&gt; 1) &amp;&amp; this._comparator.greaterThan(
        this._elements[parent], this._elements[i]);
      i = parent) {
    this._swap(parent, i);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

MinHeap.prototype.isEmpty = function () {
return this.n === 0;
};

MinHeap.prototype.insert = function (e) {
this._elements.push(e);
this.<span class="apidocCodeKeywordSpan">_siftUp</span>();
};

MinHeap.prototype.extract = function () {
var element = this._elements[1];

// Get the one from the bottom in insert it on top
// If this isn't already the last element
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.Heap.MinHeap.prototype._swap" id="apidoc.element.algorithms.DataStructures.Heap.MinHeap.prototype._swap">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.Heap.MinHeap.prototype.</span>_swap
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_swap = function (a, b) {
  var tmp = this._elements[a];
  this._elements[a] = this._elements[b];
  this._elements[b] = tmp;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
MinHeap.prototype._siftUp = function () {
 var i, parent;

 for (i = this.n;
     i &gt; 1 &amp;&amp; (parent = i &gt;&gt; 1) &amp;&amp; this._comparator.greaterThan(
       this._elements[parent], this._elements[i]);
     i = parent) {
   this.<span class="apidocCodeKeywordSpan">_swap</span>(parent, i);
 }
};

/**
* Sifts down the first element
* O(lg n)
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.Heap.MinHeap.prototype.extract" id="apidoc.element.algorithms.DataStructures.Heap.MinHeap.prototype.extract">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.Heap.MinHeap.prototype.</span>extract
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extract = function () {
  var element = this._elements[1];

  // Get the one from the bottom in insert it on top
  // If this isn't already the last element
  var last = this._elements.pop();
  if (this.n) {
    this._elements[1] = last;
    this._siftDown();
  }

  return element;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 var i;

 for (i = 0; i &lt; this._elements.length; i++) {
   elementsCopy.push(this._elements[i]);
 }

 for (i = this.n; i &gt; 0; i--) {
   fn(this.<span class="apidocCodeKeywordSpan">extract</span>());
 }

 this._elements = elementsCopy;
};

/**
* Max Heap, keeps the highest element always on top
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.Heap.MinHeap.prototype.forEach" id="apidoc.element.algorithms.DataStructures.Heap.MinHeap.prototype.forEach">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.Heap.MinHeap.prototype.</span>forEach
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forEach = function (fn) {
  // A copy is necessary in order to perform extract(),
  // get the items in sorted order and then restore the original
  // this._elements array
  var elementsCopy = [];
  var i;

  for (i = 0; i &lt; this._elements.length; i++) {
    elementsCopy.push(this._elements[i]);
  }

  for (i = this.n; i &gt; 0; i--) {
    fn(this.extract());
  }

  this._elements = elementsCopy;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    node = node.next;
  }
}
};

HashTable.prototype.forEach = function (fn) {
var applyFunction = function (linkedList) {
  linkedList.<span class="apidocCodeKeywordSpan">forEach</span>(function (elem) {
    fn(elem.k, elem.v);
  });
};

for (var i = 0; i &lt; this._table.length; i++) {
  if (this._table[i]) {
    applyFunction(this._table[i]);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.Heap.MinHeap.prototype.heapify" id="apidoc.element.algorithms.DataStructures.Heap.MinHeap.prototype.heapify">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.Heap.MinHeap.prototype.</span>heapify
        <span class="apidocSignatureSpan">(a)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">heapify = function (a) {
  if (a) {
    this._elements = a;
    this._elements.unshift(null);
  }

  for (var i = this.n &gt;&gt; 1; i &gt; 0; i--) {
    this._siftDown(i);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

PriorityQueue.prototype.priority = function (item) {
  return this._priority[item];
};

PriorityQueue.prototype.changePriority = function (item, priority) {
  this._priority[item] = priority;
  this.<span class="apidocCodeKeywordSpan">heapify</span>();
};

module.exports = PriorityQueue;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.Heap.MinHeap.prototype.insert" id="apidoc.element.algorithms.DataStructures.Heap.MinHeap.prototype.insert">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.Heap.MinHeap.prototype.</span>insert
        <span class="apidocSignatureSpan">(e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">insert = function (e) {
  this._elements.push(e);
  this._siftUp();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    insertKey = 'right';
  }

  if (!current[insertKey]) {
    current[insertKey] = new Node(value, null, null, current);
    this.keepHeightBalance(current[insertKey], false);
  } else {
    this.<span class="apidocCodeKeywordSpan">insert</span>(value, current[insertKey]);
  }
};

/**
 * In-order traversal from the given node.
 */
AVLTree.prototype.inOrder = function (current, callback) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.Heap.MinHeap.prototype.isEmpty" id="apidoc.element.algorithms.DataStructures.Heap.MinHeap.prototype.isEmpty">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.Heap.MinHeap.prototype.</span>isEmpty
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isEmpty = function () {
  return this.n === 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  get: function () {
    return this._elements.length;
  }.bind(this)
});
}

Queue.prototype.isEmpty = function () {
return this._elements.<span class="apidocCodeKeywordSpan">isEmpty</span>();
};

/**
 * Adds element to the end of the queue
 */
Queue.prototype.push = function (e) {
this._elements.add(e);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.algorithms.DataStructures.LinkedList" id="apidoc.module.algorithms.DataStructures.LinkedList">module algorithms.DataStructures.LinkedList</a></h1>


    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.LinkedList.LinkedList" id="apidoc.element.algorithms.DataStructures.LinkedList.LinkedList">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.</span>LinkedList
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function LinkedList() {

  this._length = 0;
  this.head = null;
  this.tail = null;

  // Read-only length property
  Object.defineProperty(this, 'length', {
    get: function () {
      return this._length;
    }.bind(this)
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.algorithms.DataStructures.LinkedList.prototype" id="apidoc.module.algorithms.DataStructures.LinkedList.prototype">module algorithms.DataStructures.LinkedList.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.LinkedList.prototype.add" id="apidoc.element.algorithms.DataStructures.LinkedList.prototype.add">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.LinkedList.prototype.</span>add
        <span class="apidocSignatureSpan">(n, index)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">add = function (n, index) {
  if (index &gt; this.length || index &lt; 0) {
    throw new Error('Index out of bounds');
  }

  var node = new Node(n);

  if (index !== undefined &amp;&amp; index &lt; this.length) {
    var prevNode,
        nextNode;

    if (index === 0) {
      // Insert in the beginning
      nextNode = this.head;
      this.head = node;
    } else {
      nextNode = this.getNode(index);
      prevNode = nextNode.prev;
      prevNode.next = node;
      node.prev = prevNode;
    }
    nextNode.prev = node;
    node.next = nextNode;
  } else {
    // Insert at the end
    if (!this.head) this.head = node;

    if (this.tail) {
      this.tail.next = node;
      node.prev = this.tail;
    }
    this.tail = node;
  }

  this._length++;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

Graph.prototype.addVertex = function (v) {
v = _(v);
if (this.vertices.contains(v)) {
  throw new Error('Vertex "' + v + '" has already been added');
}
this.vertices.<span class="apidocCodeKeywordSpan">add</span>(v);
this.adjList[v] = Object.create(null);
};

Graph.prototype.addEdge = function (a, b, w) {
a = _(a);
b = _(b);
// If no weight is assigned to the edge, 1 is the default
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.LinkedList.prototype.del" id="apidoc.element.algorithms.DataStructures.LinkedList.prototype.del">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.LinkedList.prototype.</span>del
        <span class="apidocSignatureSpan">(index)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">del = function (index) {
  if (index &gt;= this.length || index &lt; 0) {
    throw new Error('Index out of bounds');
  }

  this.delNode(this.getNode(index));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Pops the element in the beginning of the queue
 */
Queue.prototype.pop = function () {
if (this.isEmpty()) {
  throw new Error('Empty queue');
}
var e = this._elements.get(0);
this._elements.<span class="apidocCodeKeywordSpan">del</span>(0);
return e;
};

Queue.prototype.peek = function () {
if (this.isEmpty()) {
  throw new Error('Empty queue');
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.LinkedList.prototype.delNode" id="apidoc.element.algorithms.DataStructures.LinkedList.prototype.delNode">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.LinkedList.prototype.</span>delNode
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">delNode = function (node) {
  if (node === this.tail) {
    // node is the last element
    this.tail = node.prev;
  } else {
    node.next.prev = node.prev;
  }
  if (node === this.head) {
    // node is the first element
    this.head = node.next;
  } else {
    node.prev.next = node.next;
  }

  this._length--;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

HashTable.prototype.del = function (key) {
  var i = this._position(key);
  var node;

  if ((node = this._findInList(this._table[i], key))) {
    this._table[i].<span class="apidocCodeKeywordSpan">delNode</span>(node);
    this._items--;
  }
};

HashTable.prototype._position = function (key) {
  return Math.abs(this.hash(key)) % this.capacity;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.LinkedList.prototype.forEach" id="apidoc.element.algorithms.DataStructures.LinkedList.prototype.forEach">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.LinkedList.prototype.</span>forEach
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forEach = function (fn) {
  var node = this.head;
  while (node) {
    fn(node.value);
    node = node.next;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    node = node.next;
  }
}
};

HashTable.prototype.forEach = function (fn) {
var applyFunction = function (linkedList) {
  linkedList.<span class="apidocCodeKeywordSpan">forEach</span>(function (elem) {
    fn(elem.k, elem.v);
  });
};

for (var i = 0; i &lt; this._table.length; i++) {
  if (this._table[i]) {
    applyFunction(this._table[i]);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.LinkedList.prototype.get" id="apidoc.element.algorithms.DataStructures.LinkedList.prototype.get">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.LinkedList.prototype.</span>get
        <span class="apidocSignatureSpan">(index)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get = function (index) {
  return this.getNode(index).value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
 * Pops the element in the beginning of the queue
 */
Queue.prototype.pop = function () {
if (this.isEmpty()) {
  throw new Error('Empty queue');
}
var e = this._elements.<span class="apidocCodeKeywordSpan">get</span>(0);
this._elements.del(0);
return e;
};

Queue.prototype.peek = function () {
if (this.isEmpty()) {
  throw new Error('Empty queue');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.LinkedList.prototype.getNode" id="apidoc.element.algorithms.DataStructures.LinkedList.prototype.getNode">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.LinkedList.prototype.</span>getNode
        <span class="apidocSignatureSpan">(index)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getNode = function (index) {
  if (index &gt;= this.length || index &lt; 0) {
    throw new Error('Index out of bounds');
  }

  var node = this.head;
  for (var i = 1; i &lt;= index; i++) {
    node = node.next;
  }

  return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      nextNode;

  if (index === 0) {
    // Insert in the beginning
    nextNode = this.head;
    this.head = node;
  } else {
    nextNode = this.<span class="apidocCodeKeywordSpan">getNode</span>(index);
    prevNode = nextNode.prev;
    prevNode.next = node;
    node.prev = prevNode;
  }
  nextNode.prev = node;
  node.next = nextNode;
} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.LinkedList.prototype.isEmpty" id="apidoc.element.algorithms.DataStructures.LinkedList.prototype.isEmpty">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.LinkedList.prototype.</span>isEmpty
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isEmpty = function () {
  return this.length === 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  get: function () {
    return this._elements.length;
  }.bind(this)
});
}

Queue.prototype.isEmpty = function () {
return this._elements.<span class="apidocCodeKeywordSpan">isEmpty</span>();
};

/**
 * Adds element to the end of the queue
 */
Queue.prototype.push = function (e) {
this._elements.add(e);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.algorithms.DataStructures.PriorityQueue" id="apidoc.module.algorithms.DataStructures.PriorityQueue">module algorithms.DataStructures.PriorityQueue</a></h1>


    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.PriorityQueue.PriorityQueue" id="apidoc.element.algorithms.DataStructures.PriorityQueue.PriorityQueue">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.</span>PriorityQueue
        <span class="apidocSignatureSpan">(initialItems)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function PriorityQueue(initialItems) {

  var self = this;
  MinHeap.call(this, function (a, b) {
    return self.priority(a) &lt; self.priority(b) ? -1 : 1;
  });

  this._priority = {};

  initialItems = initialItems || {};
  Object.keys(initialItems).forEach(function (item) {
    self.insert(item, initialItems[item]);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.algorithms.DataStructures.PriorityQueue.prototype" id="apidoc.module.algorithms.DataStructures.PriorityQueue.prototype">module algorithms.DataStructures.PriorityQueue.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.PriorityQueue.prototype.changePriority" id="apidoc.element.algorithms.DataStructures.PriorityQueue.prototype.changePriority">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.PriorityQueue.prototype.</span>changePriority
        <span class="apidocSignatureSpan">(item, priority)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">changePriority = function (item, priority) {
  this._priority[item] = priority;
  this.heapify();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
});
}

PriorityQueue.prototype = new MinHeap();

PriorityQueue.prototype.insert = function (item, priority) {
if (this._priority[item] !== undefined) {
  return this.<span class="apidocCodeKeywordSpan">changePriority</span>(item, priority);
}
this._priority[item] = priority;
MinHeap.prototype.insert.call(this, item);
};

PriorityQueue.prototype.extract = function (withPriority) {
var min = MinHeap.prototype.extract.call(this);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.PriorityQueue.prototype.extract" id="apidoc.element.algorithms.DataStructures.PriorityQueue.prototype.extract">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.PriorityQueue.prototype.</span>extract
        <span class="apidocSignatureSpan">(withPriority)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extract = function (withPriority) {
  var min = MinHeap.prototype.extract.call(this);
  return withPriority ?
    min &amp;&amp; {item: min, priority: this._priority[min]} :
    min;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 var i;

 for (i = 0; i &lt; this._elements.length; i++) {
   elementsCopy.push(this._elements[i]);
 }

 for (i = this.n; i &gt; 0; i--) {
   fn(this.<span class="apidocCodeKeywordSpan">extract</span>());
 }

 this._elements = elementsCopy;
};

/**
* Max Heap, keeps the highest element always on top
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.PriorityQueue.prototype.insert" id="apidoc.element.algorithms.DataStructures.PriorityQueue.prototype.insert">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.PriorityQueue.prototype.</span>insert
        <span class="apidocSignatureSpan">(item, priority)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">insert = function (item, priority) {
  if (this._priority[item] !== undefined) {
    return this.changePriority(item, priority);
  }
  this._priority[item] = priority;
  MinHeap.prototype.insert.call(this, item);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    insertKey = 'right';
  }

  if (!current[insertKey]) {
    current[insertKey] = new Node(value, null, null, current);
    this.keepHeightBalance(current[insertKey], false);
  } else {
    this.<span class="apidocCodeKeywordSpan">insert</span>(value, current[insertKey]);
  }
};

/**
 * In-order traversal from the given node.
 */
AVLTree.prototype.inOrder = function (current, callback) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.PriorityQueue.prototype.priority" id="apidoc.element.algorithms.DataStructures.PriorityQueue.prototype.priority">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.PriorityQueue.prototype.</span>priority
        <span class="apidocSignatureSpan">(item)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">priority = function (item) {
  return this._priority[item];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * the heap operations are performed based on the priority of the element
 * and not on the element itself
 */
function PriorityQueue(initialItems) {

var self = this;
MinHeap.call(this, function (a, b) {
  return self.<span class="apidocCodeKeywordSpan">priority</span>(a) &lt; self.priority(b) ? -1 : 1;
});

this._priority = {};

initialItems = initialItems || {};
Object.keys(initialItems).forEach(function (item) {
  self.insert(item, initialItems[item]);
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.algorithms.DataStructures.Queue" id="apidoc.module.algorithms.DataStructures.Queue">module algorithms.DataStructures.Queue</a></h1>


    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.Queue.Queue" id="apidoc.element.algorithms.DataStructures.Queue.Queue">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.</span>Queue
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Queue() {
  this._elements = new LinkedList();

  Object.defineProperty(this, 'length', {
    get: function () {
      return this._elements.length;
    }.bind(this)
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.algorithms.DataStructures.Queue.prototype" id="apidoc.module.algorithms.DataStructures.Queue.prototype">module algorithms.DataStructures.Queue.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.Queue.prototype.forEach" id="apidoc.element.algorithms.DataStructures.Queue.prototype.forEach">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.Queue.prototype.</span>forEach
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forEach = function (fn) {
  this._elements.forEach(fn);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    node = node.next;
  }
}
};

HashTable.prototype.forEach = function (fn) {
var applyFunction = function (linkedList) {
  linkedList.<span class="apidocCodeKeywordSpan">forEach</span>(function (elem) {
    fn(elem.k, elem.v);
  });
};

for (var i = 0; i &lt; this._table.length; i++) {
  if (this._table[i]) {
    applyFunction(this._table[i]);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.Queue.prototype.isEmpty" id="apidoc.element.algorithms.DataStructures.Queue.prototype.isEmpty">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.Queue.prototype.</span>isEmpty
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isEmpty = function () {
  return this._elements.isEmpty();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  get: function () {
    return this._elements.length;
  }.bind(this)
});
}

Queue.prototype.isEmpty = function () {
return this._elements.<span class="apidocCodeKeywordSpan">isEmpty</span>();
};

/**
 * Adds element to the end of the queue
 */
Queue.prototype.push = function (e) {
this._elements.add(e);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.Queue.prototype.peek" id="apidoc.element.algorithms.DataStructures.Queue.prototype.peek">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.Queue.prototype.</span>peek
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">peek = function () {
  if (this.isEmpty()) {
    throw new Error('Empty queue');
  }

  return this._elements.get(0);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  assert(q.isEmpty());
  assert.throws(function () { q.pop(); }, Error);
});

it('should allow me to peek at the first element in' +
  ' line without popping it', function () {
    var q = new Queue();
    assert.throws(function () { q.<span class="apidocCodeKeywordSpan">peek</span>(); }, Error); //Empty list
    q.push(1);
    q.push(2);
    q.push(3);
    assert.equal(q.peek(), 1);
    assert.equal(q.peek(), 1);
    q.pop();
    assert.equal(q.peek(), 2);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.Queue.prototype.pop" id="apidoc.element.algorithms.DataStructures.Queue.prototype.pop">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.Queue.prototype.</span>pop
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pop = function () {
  if (this.isEmpty()) {
    throw new Error('Empty queue');
  }
  var e = this._elements.get(0);
  this._elements.del(0);
  return e;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

MinHeap.prototype.extract = function () {
  var element = this._elements[1];

  // Get the one from the bottom in insert it on top
  // If this isn't already the last element
  var last = this._elements.<span class="apidocCodeKeywordSpan">pop</span>();
  if (this.n) {
    this._elements[1] = last;
    this._siftDown();
  }

  return element;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.Queue.prototype.push" id="apidoc.element.algorithms.DataStructures.Queue.prototype.push">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.Queue.prototype.</span>push
        <span class="apidocSignatureSpan">(e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">push = function (e) {
  this._elements.add(e);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Keep the height balance property by walking to
 * root and checking for invalid heights.
 */
AVLTree.prototype.keepHeightBalance = function (node, afterRemove) {
var current = node;
var traveledNodes = [];
while (current !== null) {
  traveledNodes.<span class="apidocCodeKeywordSpan">push</span>(current);
  current.height = this.getNodeHeight(current);
  if (!this.isNodeBalanced(current)) {
    var nodesToBeRestructured = (afterRemove) ?
      this.getNodesToRestructureAfterRemove(traveledNodes) :
      this.getNodesToRestructureAfterInsert(traveledNodes);
    this.restructure(nodesToBeRestructured);
  }
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.algorithms.DataStructures.Set" id="apidoc.module.algorithms.DataStructures.Set">module algorithms.DataStructures.Set</a></h1>


    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.Set.Set" id="apidoc.element.algorithms.DataStructures.Set.Set">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.</span>Set
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Set = function () {
  this._elements = new HashTable(arguments.length);
  this.add.apply(this, arguments);

  Object.defineProperty(this, 'size', {
    get: function () {
      return this._elements.size;
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.algorithms.DataStructures.Set.prototype" id="apidoc.module.algorithms.DataStructures.Set.prototype">module algorithms.DataStructures.Set.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.Set.prototype.add" id="apidoc.element.algorithms.DataStructures.Set.prototype.add">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.Set.prototype.</span>add
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">add = function () {
  for (var i = 0; i &lt; arguments.length; i++) {
    this._elements.put(arguments[i], true);
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

Graph.prototype.addVertex = function (v) {
v = _(v);
if (this.vertices.contains(v)) {
  throw new Error('Vertex "' + v + '" has already been added');
}
this.vertices.<span class="apidocCodeKeywordSpan">add</span>(v);
this.adjList[v] = Object.create(null);
};

Graph.prototype.addEdge = function (a, b, w) {
a = _(a);
b = _(b);
// If no weight is assigned to the edge, 1 is the default
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.Set.prototype.contains" id="apidoc.element.algorithms.DataStructures.Set.prototype.contains">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.Set.prototype.</span>contains
        <span class="apidocSignatureSpan">(e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">contains = function (e) {
  return this._elements.get(e) !== undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Normalize vertex labels as strings
var _ = function (v) {
  return '' + v;
};

Graph.prototype.addVertex = function (v) {
  v = _(v);
  if (this.vertices.<span class="apidocCodeKeywordSpan">contains</span>(v)) {
    throw new Error('Vertex "' + v + '" has already been added');
  }
  this.vertices.add(v);
  this.adjList[v] = Object.create(null);
};

Graph.prototype.addEdge = function (a, b, w) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.Set.prototype.forEach" id="apidoc.element.algorithms.DataStructures.Set.prototype.forEach">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.Set.prototype.</span>forEach
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forEach = function (fn) {
  this._elements.forEach(fn);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    node = node.next;
  }
}
};

HashTable.prototype.forEach = function (fn) {
var applyFunction = function (linkedList) {
  linkedList.<span class="apidocCodeKeywordSpan">forEach</span>(function (elem) {
    fn(elem.k, elem.v);
  });
};

for (var i = 0; i &lt; this._table.length; i++) {
  if (this._table[i]) {
    applyFunction(this._table[i]);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.Set.prototype.remove" id="apidoc.element.algorithms.DataStructures.Set.prototype.remove">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.Set.prototype.</span>remove
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">remove = function () {
  for (var i = 0; i &lt; arguments.length; i++) {
    this._elements.del(arguments[i]);
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

if (node.left &amp;&amp; node.right) {
  var min = this.findMin(node.right);
  var temp = node.value;
  node.value = min.value;
  min.value = temp;
  return this.<span class="apidocCodeKeywordSpan">remove</span>(min);
} else if (node.left) {
  this.replaceChild(node.parent, node, node.left);
  this.keepHeightBalance(node.left, true);
} else if (node.right) {
  this.replaceChild(node.parent, node, node.right);
  this.keepHeightBalance(node.right, true);
} else {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.algorithms.DataStructures.Stack" id="apidoc.module.algorithms.DataStructures.Stack">module algorithms.DataStructures.Stack</a></h1>


    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.Stack.Stack" id="apidoc.element.algorithms.DataStructures.Stack.Stack">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.</span>Stack
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Stack() {
  Queue.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.algorithms.DataStructures.Stack.prototype" id="apidoc.module.algorithms.DataStructures.Stack.prototype">module algorithms.DataStructures.Stack.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.Stack.prototype.push" id="apidoc.element.algorithms.DataStructures.Stack.prototype.push">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.Stack.prototype.</span>push
        <span class="apidocSignatureSpan">(e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">push = function (e) {
  this._elements.add(e, 0);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Keep the height balance property by walking to
 * root and checking for invalid heights.
 */
AVLTree.prototype.keepHeightBalance = function (node, afterRemove) {
var current = node;
var traveledNodes = [];
while (current !== null) {
  traveledNodes.<span class="apidocCodeKeywordSpan">push</span>(current);
  current.height = this.getNodeHeight(current);
  if (!this.isNodeBalanced(current)) {
    var nodesToBeRestructured = (afterRemove) ?
      this.getNodesToRestructureAfterRemove(traveledNodes) :
      this.getNodesToRestructureAfterInsert(traveledNodes);
    this.restructure(nodesToBeRestructured);
  }
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.algorithms.DataStructures.Treap" id="apidoc.module.algorithms.DataStructures.Treap">module algorithms.DataStructures.Treap</a></h1>


    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.Treap.Treap" id="apidoc.element.algorithms.DataStructures.Treap.Treap">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.</span>Treap
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Treap() {
  this.root = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.algorithms.DataStructures.Treap.prototype" id="apidoc.module.algorithms.DataStructures.Treap.prototype">module algorithms.DataStructures.Treap.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.Treap.prototype._find" id="apidoc.element.algorithms.DataStructures.Treap.prototype._find">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.Treap.prototype.</span>_find
        <span class="apidocSignatureSpan">(node, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_find = function (node, value) {
  if (node === null) {
    // Empty tree
    return false;
  }
  if (node.value === value) {
    // Found!
    return true;
  }

  // Search within childnodes
  var side = ~~(value &gt; node.value);
  return this._find(node.children[side], value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.preOrder(current.right, callback);
};

/**
 * Finds a node by its value.
 */
AVLTree.prototype.find = function (value) {
return this.<span class="apidocCodeKeywordSpan">_find</span>(value, this.root);
};

/**
 * Finds a node by its value in the given sub-tree.
 */
AVLTree.prototype._find = function (value, current) {
if (!current) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.Treap.prototype._insert" id="apidoc.element.algorithms.DataStructures.Treap.prototype._insert">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.Treap.prototype.</span>_insert
        <span class="apidocSignatureSpan">(node, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_insert = function (node, value) {
  if (node === null) {
    return new Node(value, null, null);
  }

  // Passing to childnodes and update
  var side = ~~(value &gt; node.value);
  node.children[side] = this._insert(node.children[side], value);

  // Keep it balance
  if (node.children[side].key &lt; node.key) {
	return node.rotate(side);
  } else {
	return node.resize();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Treap.prototype._insert = function (node, value) {
if (node === null) {
  return new Node(value, null, null);
}

// Passing to childnodes and update
var side = ~~(value &gt; node.value);
node.children[side] = this.<span class="apidocCodeKeywordSpan">_insert</span>(node.children[side], value);

// Keep it balance
if (node.children[side].key &lt; node.key) {
	return node.rotate(side);
} else {
	return node.resize();
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.Treap.prototype._maximum" id="apidoc.element.algorithms.DataStructures.Treap.prototype._maximum">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.Treap.prototype.</span>_maximum
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_maximum = function (node) {
  if (node === null) {
    // Empty tree, returns -Infinity
    return -Infinity;
  }

  return Math.max(node.value, this._maximum(node.children[1]));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Treap.prototype._maximum = function (node) {
if (node === null) {
  // Empty tree, returns -Infinity
  return -Infinity;
}

return Math.max(node.value, this.<span class="apidocCodeKeywordSpan">_maximum</span>(node.children[1]));
};

Treap.prototype._remove = function (node, value) {
if (node === null) {
  // Empty node, value not found
  return null;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.Treap.prototype._minimum" id="apidoc.element.algorithms.DataStructures.Treap.prototype._minimum">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.Treap.prototype.</span>_minimum
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_minimum = function (node) {
  if (node === null) {
    // Empty tree, returns Infinity
    return Infinity;
  }

  return Math.min(node.value, this._minimum(node.children[0]));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Treap.prototype._minimum = function (node) {
if (node === null) {
  // Empty tree, returns Infinity
  return Infinity;
}

return Math.min(node.value, this.<span class="apidocCodeKeywordSpan">_minimum</span>(node.children[0]));
};

Treap.prototype._maximum = function (node) {
if (node === null) {
  // Empty tree, returns -Infinity
  return -Infinity;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.Treap.prototype._remove" id="apidoc.element.algorithms.DataStructures.Treap.prototype._remove">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.Treap.prototype.</span>_remove
        <span class="apidocSignatureSpan">(node, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_remove = function (node, value) {
  if (node === null) {
    // Empty node, value not found
    return null;
  }

  var side;

  if (node.value === value) {
    if (node.children[0] === null &amp;&amp; node.children[1] === null) {
      // It's a leaf, set to null
      return null;
    }

	// Rotate to a subtree and remove it
	side = (node.children[0] === null ? 1 : 0);
	node = node.rotate(side);
  	node.children[1 - side] = this._remove(node.children[1 - side], value);
  	return node.resize();
  } else {
    side = ~~(value &gt; node.value);
    node.children[side] = this._remove(node.children[side], value);
  	return node.resize();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      // It's a leaf, set to null
      return null;
    }

	// Rotate to a subtree and remove it
	side = (node.children[0] === null ? 1 : 0);
	node = node.rotate(side);
  	node.children[1 - side] = this.<span class="apidocCodeKeywordSpan">_remove</span>(node.children[1 - side], value);
  	return node.resize();
  } else {
    side = ~~(value &gt; node.value);
    node.children[side] = this._remove(node.children[side], value);
  	return node.resize();
  }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.Treap.prototype.find" id="apidoc.element.algorithms.DataStructures.Treap.prototype.find">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.Treap.prototype.</span>find
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">find = function (value) {
  return this._find(this.root, value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
};

/**
 * Removes a node by its value.
 */
AVLTree.prototype.remove = function (value) {
var node = this.<span class="apidocCodeKeywordSpan">find</span>(value);
if (!node) {
  return false;
}

if (node.left &amp;&amp; node.right) {
  var min = this.findMin(node.right);
  var temp = node.value;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.Treap.prototype.height" id="apidoc.element.algorithms.DataStructures.Treap.prototype.height">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.Treap.prototype.</span>height
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">height = function () {
  return this.root ? this.root.height : 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  it('should keep balance', function () {
	// Insert 1023 elements randomly
	for (var i = 0; i &lt; 1023; ++i) {
	  treap.insert(Math.random());
	}
	assert.equal(treap.size(), 1023);
	// The averange height should be 23 (with an error of 5)
	assert(Math.abs(treap.<span class="apidocCodeKeywordSpan">height</span>() - 23) &lt; 5);
  });

  it('should rotate correctly', function () {
  	// Force clear the tree
	treap.root = null;
treap.insert(1);
// 1
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.Treap.prototype.insert" id="apidoc.element.algorithms.DataStructures.Treap.prototype.insert">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.Treap.prototype.</span>insert
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">insert = function (value) {
  this.root = this._insert(this.root, value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    insertKey = 'right';
  }

  if (!current[insertKey]) {
    current[insertKey] = new Node(value, null, null, current);
    this.keepHeightBalance(current[insertKey], false);
  } else {
    this.<span class="apidocCodeKeywordSpan">insert</span>(value, current[insertKey]);
  }
};

/**
 * In-order traversal from the given node.
 */
AVLTree.prototype.inOrder = function (current, callback) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.Treap.prototype.maximum" id="apidoc.element.algorithms.DataStructures.Treap.prototype.maximum">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.Treap.prototype.</span>maximum
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">maximum = function () {
  return this._maximum(this.root);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  treap.remove(-100);
  // [2, 3, 10, 100]
  assert.equal(treap.minimum(), 2);
});

it('should get maximum element', function () {
  // [2, 3, 10, 100]
  assert.equal(treap.<span class="apidocCodeKeywordSpan">maximum</span>(), 100);
  treap.remove(100);
  // [2, 3, 10]
  assert.equal(treap.maximum(), 10);
  treap.remove(10);
  // [2, 3]
  assert.equal(treap.maximum(), 3);
  treap.remove(3);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.Treap.prototype.minimum" id="apidoc.element.algorithms.DataStructures.Treap.prototype.minimum">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.Treap.prototype.</span>minimum
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">minimum = function () {
  return this._minimum(this.root);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  assert.equal(treap.find(-100), false);
  assert.equal(treap.find(-1), false);
  assert.equal(treap.find(101), false);
});

it('should get minimum element', function () {
  // [1, 2, 3, 10, 100]
  assert.equal(treap.<span class="apidocCodeKeywordSpan">minimum</span>(), 1);
  treap.remove(1);
  // [2, 3, 10, 100]
  assert.equal(treap.minimum(), 2);
  treap.insert(-100);
  // [-100, 2, 3, 10, 100]
  assert.equal(treap.minimum(), -100);
  treap.remove(-100);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.Treap.prototype.remove" id="apidoc.element.algorithms.DataStructures.Treap.prototype.remove">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.Treap.prototype.</span>remove
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">remove = function (value) {
  this.root = this._remove(this.root, value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

if (node.left &amp;&amp; node.right) {
  var min = this.findMin(node.right);
  var temp = node.value;
  node.value = min.value;
  min.value = temp;
  return this.<span class="apidocCodeKeywordSpan">remove</span>(min);
} else if (node.left) {
  this.replaceChild(node.parent, node, node.left);
  this.keepHeightBalance(node.left, true);
} else if (node.right) {
  this.replaceChild(node.parent, node, node.right);
  this.keepHeightBalance(node.right, true);
} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.DataStructures.Treap.prototype.size" id="apidoc.element.algorithms.DataStructures.Treap.prototype.size">
        function <span class="apidocSignatureSpan">algorithms.DataStructures.Treap.prototype.</span>size
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">size = function () {
  return this.root ? this.root.size : 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      assert(!forest.sameSubset(1, 5));
    });

it('should maintain subset sizes', function () {
  var forest = new DisjointSetForest();
  var assertSizesCorrect = function (elements, size) {
    elements.forEach(function (element) {
      assert.equal(forest.<span class="apidocCodeKeywordSpan">size</span>(element), size);
    });
  };
  assertSizesCorrect([0, 1, 2, 3, 4], 1);
  forest.merge(0, 1);
  assertSizesCorrect([0, 1], 2);
  forest.merge(0, 2);
  assertSizesCorrect([0, 1, 2], 3);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.algorithms.Geometry" id="apidoc.module.algorithms.Geometry">module algorithms.Geometry</a></h1>


    <h2>
        <a href="#apidoc.element.algorithms.Geometry.BezierCurve" id="apidoc.element.algorithms.Geometry.BezierCurve">
        function <span class="apidocSignatureSpan">algorithms.Geometry.</span>BezierCurve
        <span class="apidocSignatureSpan">(points)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">BezierCurve = function (points) {
  this.n = points.length;
  this.p = [];

  // The binomial coefficient
  var c = [1];
  var i, j;
  for (i = 1; i &lt; this.n; ++i) {
    c.push(0);
    for (j = i; j &gt;= 1; --j) {
        c[j] += c[j - 1];
    }
  }

  // the i-th control point times the coefficient
  for (i = 0; i &lt; this.n; ++i) {
    this.p.push({x: c[i] * points[i].x, y: c[i] * points[i].y});
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.algorithms.Geometry.BezierCurve" id="apidoc.module.algorithms.Geometry.BezierCurve">module algorithms.Geometry.BezierCurve</a></h1>


    <h2>
        <a href="#apidoc.element.algorithms.Geometry.BezierCurve.BezierCurve" id="apidoc.element.algorithms.Geometry.BezierCurve.BezierCurve">
        function <span class="apidocSignatureSpan">algorithms.Geometry.</span>BezierCurve
        <span class="apidocSignatureSpan">(points)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">BezierCurve = function (points) {
  this.n = points.length;
  this.p = [];

  // The binomial coefficient
  var c = [1];
  var i, j;
  for (i = 1; i &lt; this.n; ++i) {
    c.push(0);
    for (j = i; j &gt;= 1; --j) {
        c[j] += c[j - 1];
    }
  }

  // the i-th control point times the coefficient
  for (i = 0; i &lt; this.n; ++i) {
    this.p.push({x: c[i] * points[i].x, y: c[i] * points[i].y});
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.algorithms.Geometry.BezierCurve.prototype" id="apidoc.module.algorithms.Geometry.BezierCurve.prototype">module algorithms.Geometry.BezierCurve.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.algorithms.Geometry.BezierCurve.prototype.get" id="apidoc.element.algorithms.Geometry.BezierCurve.prototype.get">
        function <span class="apidocSignatureSpan">algorithms.Geometry.BezierCurve.prototype.</span>get
        <span class="apidocSignatureSpan">(t)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get = function (t) {
  var res = {x: 0, y: 0};
  var i;
  var a = 1, b = 1;

  // The coefficient
  var c = [];
  for (i = 0; i &lt; this.n; ++i) {
    c.push(a);
    a *= t;
  }

  for (i = this.n - 1; i &gt;= 0; --i) {
    res.x += this.p[i].x * c[i] * b;
    res.y += this.p[i].y * c[i] * b;
    b *= 1 - t;
  }
  return res;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
 * Pops the element in the beginning of the queue
 */
Queue.prototype.pop = function () {
if (this.isEmpty()) {
  throw new Error('Empty queue');
}
var e = this._elements.<span class="apidocCodeKeywordSpan">get</span>(0);
this._elements.del(0);
return e;
};

Queue.prototype.peek = function () {
if (this.isEmpty()) {
  throw new Error('Empty queue');
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.algorithms.Graph" id="apidoc.module.algorithms.Graph">module algorithms.Graph</a></h1>


    <h2>
        <a href="#apidoc.element.algorithms.Graph.SPFA" id="apidoc.element.algorithms.Graph.SPFA">
        function <span class="apidocSignatureSpan">algorithms.Graph.</span>SPFA
        <span class="apidocSignatureSpan">(graph, s)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function spfa(graph, s) {
  var distance = {};
  var previous = {};
  var queue = {};
  var isInQue = {};
  var cnt = {};
  var head = 0;
  var tail = 1;
  // initialize
  distance[s] = 0;
  queue[0] = s;
  isInQue[s] = true;
  cnt[s] = 1;
  graph.vertices.forEach(function (v) {
    if (v !== s) {
      distance[v] = Infinity;
      isInQue[v] = false;
      cnt[v] = 0;
    }
  });

  var currNode;
  while (head !== tail) {
    currNode = queue[head++];
    isInQue[currNode] = false;
    var neighbors = graph.neighbors(currNode);
    for (var i = 0; i &lt; neighbors.length; i++) {
      var v = neighbors[i];
      // relaxation
      var newDistance = distance[currNode] + graph.edge(currNode, v);
      if (newDistance &lt; distance[v]) {
        distance[v] = newDistance;
        previous[v] = currNode;
        if (!isInQue[v]) {
          queue[tail++] = v;
          isInQue[v] = true;
          cnt[v]++;
          if (cnt[v] &gt; graph.vertices.size)
            // indicates negative-weighted cycle
            return {
              distance: {}
            };
        }
      }
    }
  }

  return {
    distance: distance,
    previous: previous
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.Graph.bellmanFord" id="apidoc.element.algorithms.Graph.bellmanFord">
        function <span class="apidocSignatureSpan">algorithms.Graph.</span>bellmanFord
        <span class="apidocSignatureSpan">(graph, startNode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bellmanFord = function (graph, startNode) {
  var minDistance = {};
  var previousVertex = {};
  var edges = [];
  var adjacencyListSize = 0;

  // Add all the edges from the graph to the 'edges' array
  graph.vertices.forEach(function (s) {
    graph.neighbors(s).forEach(function (t) {
      edges.push({
        source: s,
        target: t,
        weight: graph.edge(s, t)
      });
    });

    minDistance[s] = Infinity;
    ++adjacencyListSize;
  });

  minDistance[startNode] = 0;

  var edgesSize = edges.length;
  var sourceDistance;
  var targetDistance;

  var iteration;
  for (iteration = 0; iteration &lt; adjacencyListSize; ++iteration) {
    var somethingChanged = false;

    for (var j = 0; j &lt; edgesSize; j++) {
      sourceDistance = minDistance[edges[j].source] + edges[j].weight;
      targetDistance = minDistance[edges[j].target];

      if (sourceDistance &lt; targetDistance) {
        somethingChanged = true;
        minDistance[edges[j].target] = sourceDistance;
        previousVertex[edges[j].target] = edges[j].source;
      }
    }

    if (!somethingChanged) {
      // Early stop.
      break;
    }
  }

  // If the loop did not break early, then there is a negative-weighted cycle.
  if (iteration === adjacencyListSize) {
    // Empty 'distance' object indicates Negative-Weighted Cycle
    return {
      distance: {}
    };
  }

  return {
    distance: minDistance,
    previous: previousVertex
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.Graph.bfsShortestPath" id="apidoc.element.algorithms.Graph.bfsShortestPath">
        function <span class="apidocSignatureSpan">algorithms.Graph.</span>bfsShortestPath
        <span class="apidocSignatureSpan">(graph, source)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bfsShortestPath = function (graph, source) {
  var distance = {}, previous = {};
  distance[source] = 0;

  breadthFirstSearch(graph, source, {
    onTraversal: function (vertex, neighbor) {
      distance[neighbor] = distance[vertex] + 1;
      previous[neighbor] = vertex;
    }
  });

  return {
    distance: distance,
    previous: previous
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.Graph.breadthFirstSearch" id="apidoc.element.algorithms.Graph.breadthFirstSearch">
        function <span class="apidocSignatureSpan">algorithms.Graph.</span>breadthFirstSearch
        <span class="apidocSignatureSpan">(graph, startVertex, callbacks)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">breadthFirstSearch = function (graph, startVertex, callbacks) {
  var vertexQueue = new Queue();
  vertexQueue.push(startVertex);
  callbacks = normalizeCallbacks(callbacks, [startVertex]);

  var vertex;
  var enqueue = function (neighbor) {
    if (callbacks.allowTraversal(vertex, neighbor)) {
      callbacks.onTraversal(vertex, neighbor);
      vertexQueue.push(neighbor);
    }
  };

  while (!vertexQueue.isEmpty()) {
    vertex = vertexQueue.pop();
    callbacks.enterVertex(vertex);
    graph.neighbors(vertex).forEach(enqueue);
    callbacks.leaveVertex(vertex);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.Graph.depthFirstSearch" id="apidoc.element.algorithms.Graph.depthFirstSearch">
        function <span class="apidocSignatureSpan">algorithms.Graph.</span>depthFirstSearch
        <span class="apidocSignatureSpan">(graph, startVertex, callbacks)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">depthFirstSearch = function (graph, startVertex, callbacks) {
  dfsLoop(graph, startVertex, normalizeCallbacks(callbacks, [startVertex]));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.Graph.dijkstra" id="apidoc.element.algorithms.Graph.dijkstra">
        function <span class="apidocSignatureSpan">algorithms.Graph.</span>dijkstra
        <span class="apidocSignatureSpan">(graph, s)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function dijkstra(graph, s) {
  var distance = {};
  var previous = {};
  var q = new PriorityQueue();
  // Initialize
  distance[s] = 0;
  graph.vertices.forEach(function (v) {
    if (v !== s) {
      distance[v] = Infinity;
    }
    q.insert(v, distance[v]);
  });

  var currNode;
  var relax = function (v) {
    var newDistance = distance[currNode] + graph.edge(currNode, v);
    if (newDistance &lt; distance[v]) {
      distance[v] = newDistance;
      previous[v] = currNode;
      q.changePriority(v, distance[v]);
    }
  };
  while (!q.isEmpty()) {
    currNode = q.extract();
    graph.neighbors(currNode).forEach(relax);
  }
  return {
    distance: distance,
    previous: previous
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.Graph.eulerPath" id="apidoc.element.algorithms.Graph.eulerPath">
        function <span class="apidocSignatureSpan">algorithms.Graph.</span>eulerPath
        <span class="apidocSignatureSpan">(graph)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">eulerPath = function (graph) {
  if (!graph.vertices.size) {
    return [];
  }

  var endpoints = eulerEndpoints(graph);
  var route = [endpoints.finish];

  var seen = new Graph(graph.directed);
  graph.vertices.forEach(seen.addVertex.bind(seen));

  depthFirstSearch(graph, endpoints.start, {
    allowTraversal: function (vertex, neighbor) {
      return !seen.edge(vertex, neighbor);
    },
    beforeTraversal: function (vertex, neighbor) {
      seen.addEdge(vertex, neighbor);
    },
    afterTraversal: function (vertex) {
      route.push(vertex);
    }
  });

  graph.vertices.forEach(function (vertex) {
    if (seen.neighbors(vertex).length &lt; graph.neighbors(vertex).length) {
      throw new Error('There is no euler path for a disconnected graph.');
    }
  });
  return route.reverse();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.Graph.floydWarshall" id="apidoc.element.algorithms.Graph.floydWarshall">
        function <span class="apidocSignatureSpan">algorithms.Graph.</span>floydWarshall
        <span class="apidocSignatureSpan">(graph)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">floydWarshall = function (graph) {

  // Fill in the distances with initial values:
  //   - 0 if source == destination;
  //   - edge(source, destination) if there is a direct edge;
  //   - +inf otherwise.
  var distance = Object.create(null);
  graph.vertices.forEach(function (src) {
    distance[src] = Object.create(null);
    graph.vertices.forEach(function (dest) {
      if (src === dest) {
        distance[src][dest] = 0;
      } else if (graph.edge(src, dest) !== undefined) {
        distance[src][dest] = graph.edge(src, dest);
      } else {
        distance[src][dest] = Infinity;
      }
    });
  });

  // Internal vertex with the largest index along the shortest path.
  // Needed for path reconstruction.
  var middleVertex = Object.create(null);
  graph.vertices.forEach(function (vertex) {
    middleVertex[vertex] = Object.create(null);
  });

  graph.vertices.forEach(function (middle) {
    graph.vertices.forEach(function (src) {
      graph.vertices.forEach(function (dest) {
        var dist = distance[src][middle] + distance[middle][dest];
        if (dist &lt; distance[src][dest]) {
          distance[src][dest] = dist;
          middleVertex[src][dest] = middle;
        }
      });
    });
  });

  // Check for a negative-weighted cycle.
  graph.vertices.forEach(function (vertex) {
    if (distance[vertex][vertex] &lt; 0) {
      // Negative-weighted cycle found.
      throw new Error('The graph contains a negative-weighted cycle!');
    }
  });

<span class="apidocCodeCommentSpan">  /**
   * Reconstruct the shortest path for a given pair of end vertices.
   * Complexity: O(L), L - length of the path (number of edges).
   *
   * @param {string} srce
   * @param {string} dest
   * @return {?string[]} Null if destination is unreachable.
   */
</span>  var path = function (src, dest) {
    if (!Number.isFinite(distance[src][dest])) {
      // dest unreachable.
      return null;
    }

    var path = [src];

    if (src !== dest) {
      (function pushInOrder(src, dest) {
        if (middleVertex[src][dest] === undefined) {
          path.push(dest);
        } else {
          var middle = middleVertex[src][dest];
          pushInOrder(src, middle);
          pushInOrder(middle, dest);
        }
      })(src, dest);
    }

    return path;
  };

  return {
    distance: distance,
    path: path
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.Graph.kruskal" id="apidoc.element.algorithms.Graph.kruskal">
        function <span class="apidocSignatureSpan">algorithms.Graph.</span>kruskal
        <span class="apidocSignatureSpan">(graph)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">kruskal = function (graph) {
  if (graph.directed) {
    throw new Error('Can\'t build MST of a directed graph.');
  }

  var connectedComponents = new DisjointSetForest();
  var mst = new Graph(false);
  graph.vertices.forEach(mst.addVertex.bind(mst));

  var edges = [];
  graph.vertices.forEach(function (vertex) {
    graph.neighbors(vertex).forEach(function (neighbor) {
      // Compared as strings, loops intentionally omitted.
      if (vertex &lt; neighbor) {
        edges.push({
          ends: [vertex, neighbor],
          weight: graph.edge(vertex, neighbor)
        });
      }
    });
  });

  edges.sort(function (a, b) {
    return a.weight - b.weight;
  }).forEach(function (edge) {
    if (!connectedComponents.sameSubset(edge.ends[0], edge.ends[1])) {
      mst.addEdge(edge.ends[0], edge.ends[1], edge.weight);
      connectedComponents.merge(edge.ends[0], edge.ends[1]);
    }
  });

  return mst;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.Graph.prim" id="apidoc.element.algorithms.Graph.prim">
        function <span class="apidocSignatureSpan">algorithms.Graph.</span>prim
        <span class="apidocSignatureSpan">(graph)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">prim = function (graph) {
  if (graph.directed) {
    throw new Error('Can\'t build MST of a directed graph.');
  }

  var mst = new Graph(false);
  var parent = Object.create(null);

  var q = new PriorityQueue();
  graph.vertices.forEach(function (vertex) {
    q.insert(vertex, Infinity);
  });

  var relax = function (vertex, neighbor) {
    var weight = graph.edge(vertex, neighbor);
    if (weight &lt; q.priority(neighbor)) {
      q.changePriority(neighbor, weight);
      parent[neighbor] = vertex;
    }
  };

  while (!q.isEmpty()) {
    var top = q.extract(true);
    var vertex = top.item,
        weight = top.priority;

    if (parent[vertex]) {
      mst.addEdge(parent[vertex], vertex, weight);
    }
    else {
      mst.addVertex(vertex);
    }

    graph.neighbors(vertex).forEach(relax.bind(null, vertex));
  }

  return mst;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.Graph.topologicalSort" id="apidoc.element.algorithms.Graph.topologicalSort">
        function <span class="apidocSignatureSpan">algorithms.Graph.</span>topologicalSort
        <span class="apidocSignatureSpan">(graph)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">topologicalSort = function (graph) {
  var stack = new Stack();
  var firstHit = {};
  var time = 0;

  graph.vertices.forEach(function (node) {
    if (!firstHit[node]) {
      depthFirstSearch(graph, node, {
        allowTraversal: function (node, neighbor) {
          return !firstHit[neighbor];
        },
        enterVertex: function (node) {
          firstHit[node] = ++time;
        },
        leaveVertex: function (node) {
          stack.push(node);
        }
      });
    }
  });

  return stack;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.algorithms.Math" id="apidoc.module.algorithms.Math">module algorithms.Math</a></h1>


    <h2>
        <a href="#apidoc.element.algorithms.Math.extendedEuclidean" id="apidoc.element.algorithms.Math.extendedEuclidean">
        function <span class="apidocSignatureSpan">algorithms.Math.</span>extendedEuclidean
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extendedEuclidean = function (a, b) {
  var s = 0, oldS = 1;
  var t = 1, oldT = 0;
  var r = b, oldR = a;
  var quotient, temp;
  while (r !== 0) {
    quotient = Math.floor(oldR / r);

    temp = r;
    r = oldR - quotient * r;
    oldR = temp;

    temp = s;
    s = oldS - quotient * s;
    oldS = temp;

    temp = t;
    t = oldT - quotient * t;
    oldT = temp;
  }

  return {
    x: oldS,
    y: oldT
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.Math.fastPower" id="apidoc.element.algorithms.Math.fastPower">
        function <span class="apidocSignatureSpan">algorithms.Math.</span>fastPower
        <span class="apidocSignatureSpan">(base, power, mul, identity)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fastPower = function (base, power, mul, identity) {
  if (mul === undefined) {
    mul = multiplicationOperator;
    identity = 1;
  }
  if (power &lt; 0 || Math.floor(power) !== power) {
    throw new Error('Power must be a positive integer or zero.');
  }

  // If the power is zero, identity value must be given (or set by default).
  if (!power) {
    if (identity === undefined) {
      throw new Error('The power is zero, but identity value not set.');
    }
    else {
      return identity;
    }
  }

  // Iterative form of the algorithm avoids checking the same thing twice.
  var result;
  var multiplyBy = function (value) {
    result = (result === undefined) ? value : mul(result, value);
  };
  for (var factor = base; power; power &gt;&gt;&gt;= 1, factor = mul(factor, factor)) {
    if (power &amp; 1) {
      multiplyBy(factor);
    }
  }
  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.Math.fibonacci" id="apidoc.element.algorithms.Math.fibonacci">
        function <span class="apidocSignatureSpan">algorithms.Math.</span>fibonacci
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fibonacci = function (n) {
  var fibNMinus2 = 0,
      fibNMinus1 = 1,
      fib = n;
  for (var i = 1; i &lt; n; i++) {
    fib = fibNMinus1 + fibNMinus2;
    fibNMinus2 = fibNMinus1;
    fibNMinus1 = fib;
  }
  return fib;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.Math.fisherYates" id="apidoc.element.algorithms.Math.fisherYates">
        function <span class="apidocSignatureSpan">algorithms.Math.</span>fisherYates
        <span class="apidocSignatureSpan">(a)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fisherYates = function (a) {
  for (var i = a.length - 1; i &gt; 0; i--) {
    var j = Math.floor(Math.random() * (i + 1));
    var tmp = a[i];
    a[i] = a[j];
    a[j] = tmp;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.Math.gcd" id="apidoc.element.algorithms.Math.gcd">
        function <span class="apidocSignatureSpan">algorithms.Math.</span>gcd
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">gcd = function (a, b) {
  var tmp = a;
  a = Math.max(a, b);
  b = Math.min(tmp, b);
  while (b !== 0) {
    tmp = b;
    b = a % b;
    a = tmp;
  }

  return a;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.Math.greatestDifference" id="apidoc.element.algorithms.Math.greatestDifference">
        function <span class="apidocSignatureSpan">algorithms.Math.</span>greatestDifference
        <span class="apidocSignatureSpan">(numbers)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">greatestDifference = function (numbers) {
  var index = 0;
  var largest = numbers[0];
  var length = numbers.length;
  var number;
  var smallest = numbers[0];

  for (index; index &lt; length; index++) {
    number = numbers[index];

    if (number &gt; largest) largest = number;
    if (number &lt; smallest) smallest = number;
  }

  return largest - smallest;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.Math.lcm" id="apidoc.element.algorithms.Math.lcm">
        function <span class="apidocSignatureSpan">algorithms.Math.</span>lcm
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lcm = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.Math.newtonSqrt" id="apidoc.element.algorithms.Math.newtonSqrt">
        function <span class="apidocSignatureSpan">algorithms.Math.</span>newtonSqrt
        <span class="apidocSignatureSpan">(n, tolerance, maxIterations)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">newtonSqrt = function (n, tolerance, maxIterations) {
  tolerance = tolerance || 1e-7;
  maxIterations = maxIterations || 1e7;

  var upperBound = n;
  var lowerBound = 0;

  var i = 0;
  var square, x;
  do {
    i++;
    x = (upperBound - lowerBound) / 2 + lowerBound;
    square = x * x;
    if (square &lt; n) lowerBound = x;
    else upperBound = x;
  } while (Math.abs(square - n) &gt; tolerance &amp;&amp; i &lt; maxIterations);

  // Checks if the number is a perfect square to return the exact root
  var roundX = Math.round(x);
  if (roundX * roundX === n) x = roundX;

  return x;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.Math.nextPermutation" id="apidoc.element.algorithms.Math.nextPermutation">
        function <span class="apidocSignatureSpan">algorithms.Math.</span>nextPermutation
        <span class="apidocSignatureSpan">(array, compareFn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nextPermutation = function (array, compareFn) {
  if (!array.length) {
    return false;
  }
  var cmp = new Comparator(compareFn);

  // Find pivot and successor indices.
  var pivot = array.length - 1;
  while (pivot &amp;&amp; cmp.greaterThanOrEqual(array[pivot - 1], array[pivot])) {
    pivot -= 1;
  }
  if (!pivot) {
    // Permutation is sorted in descending order.
    return false;
  }
  var pivotValue = array[--pivot];
  var successor = array.length - 1;
  while (cmp.lessThanOrEqual(array[successor], pivotValue)) {
    successor -= 1;
  }

  // Swap values.
  array[pivot] = array[successor];
  array[successor] = pivotValue;

  // Reverse the descending part.
  for (var left = pivot, right = array.length; ++left &lt; --right;) {
    var temp = array[left];
    array[left] = array[right];
    array[right] = temp;
  }
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.Math.powerSet" id="apidoc.element.algorithms.Math.powerSet">
        function <span class="apidocSignatureSpan">algorithms.Math.</span>powerSet
        <span class="apidocSignatureSpan">(array)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">powerSet = function (array) {

  if (array.length === 0) {
    return [];
  }

  var powerSet = [];
  var cache = [];
  var i;

  for (i = 0; i &lt; array.length; i++) {
    cache[i] = true;
  }

  for (i = 0; i &lt; Math.pow(2, array.length); i++) {

    powerSet.push([]);

    for (var j = 0; j &lt; array.length; j++) {

      if (i % Math.pow(2, j) === 0) {
        cache[j] = !cache[j];
      }

      if (cache[j]) {
        powerSet[i].push(array[j]);
      }

    }
  }

  return powerSet;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.Math.reservoirSampling" id="apidoc.element.algorithms.Math.reservoirSampling">
        function <span class="apidocSignatureSpan">algorithms.Math.</span>reservoirSampling
        <span class="apidocSignatureSpan">(array, sampleSize)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reservoirSampling = function (array, sampleSize) {
  if (sampleSize &gt; array.length) {
    throw new Error('Sample size exceeds the total number of elements.');
  }
  var reservoir = array.slice(0, sampleSize);
  for (var i = sampleSize; i &lt; array.length; ++i) {
    var j = Math.floor(Math.random() * (i + 1));
    if (j &lt; sampleSize) {
      reservoir[j] = array[i];
    }
  }
  return reservoir;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.Math.shannonEntropy" id="apidoc.element.algorithms.Math.shannonEntropy">
        function <span class="apidocSignatureSpan">algorithms.Math.</span>shannonEntropy
        <span class="apidocSignatureSpan">(arr)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">shannonEntropy = function (arr) {
  // find the frequency of each value
  var freqs = arr.reduce(function (acc, item) {
    acc[item] = acc[item] + 1 || 1;
    return acc;
  }, {});

  // find the probability of each value
  var probs = Object.keys(freqs).map(function (key) {
    return freqs[key] / arr.length;
  });

  // calulate the shannon entropy of the array
  return probs.reduce(function (e, p) {
    return e - p * Math.log(p);
  }, 0) * Math.LOG2E;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.algorithms.Math.collatzConjecture" id="apidoc.module.algorithms.Math.collatzConjecture">module algorithms.Math.collatzConjecture</a></h1>


    <h2>
        <a href="#apidoc.element.algorithms.Math.collatzConjecture.calculate" id="apidoc.element.algorithms.Math.collatzConjecture.calculate">
        function <span class="apidocSignatureSpan">algorithms.Math.collatzConjecture.</span>calculate
        <span class="apidocSignatureSpan">(number)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function calculateCollatzConjecture(number) {
  if (number in cache) return cache[number];
  if (number % 2 === 0) return cache[number] = number &gt;&gt; 1;

  return cache[number] = number * 3 + 1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var math = require('../../..').Math,
  collatzConjecture = math.collatzConjecture,
  assert = require('assert');

describe('Collatz Conjecture', function () {
it('should return odd numbers divided by two', function () {
  assert.equal(collatzConjecture.<span class="apidocCodeKeywordSpan">calculate</span>(200), 100);
  assert.equal(collatzConjecture.calculate(222), 111);
  assert.equal(collatzConjecture.calculate(444), 222);
});

it('should return even numbers multiplied by 3 + 1', function () {
  assert.equal(collatzConjecture.calculate(111), 334);
  assert.equal(collatzConjecture.calculate(333), 1000);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.Math.collatzConjecture.generate" id="apidoc.element.algorithms.Math.collatzConjecture.generate">
        function <span class="apidocSignatureSpan">algorithms.Math.collatzConjecture.</span>generate
        <span class="apidocSignatureSpan">(number)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function generateCollatzConjecture(number) {
  var collatzConjecture = [];

  do {
    number = calculateCollatzConjecture(number);
    collatzConjecture.push(number);
  } while (number !== 1);

  return collatzConjecture;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  it('should return even numbers multiplied by 3 + 1', function () {
    assert.equal(collatzConjecture.calculate(111), 334);
    assert.equal(collatzConjecture.calculate(333), 1000);
    assert.equal(collatzConjecture.calculate(555), 1666);
  });

  it('should return Collatz Conjecture sequence ', function () {
    assert.deepEqual(collatzConjecture.<span class="apidocCodeKeywordSpan">generate</span>(10), [5, 16, 8, 4, 2, 1]);
  });
});
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.algorithms.Math.fibonacci" id="apidoc.module.algorithms.Math.fibonacci">module algorithms.Math.fibonacci</a></h1>


    <h2>
        <a href="#apidoc.element.algorithms.Math.fibonacci.fibonacci" id="apidoc.element.algorithms.Math.fibonacci.fibonacci">
        function <span class="apidocSignatureSpan">algorithms.Math.</span>fibonacci
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fibonacci = function (n) {
  var fibNMinus2 = 0,
      fibNMinus1 = 1,
      fib = n;
  for (var i = 1; i &lt; n; i++) {
    fib = fibNMinus1 + fibNMinus2;
    fibNMinus2 = fibNMinus1;
    fibNMinus1 = fib;
  }
  return fib;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.Math.fibonacci.direct" id="apidoc.element.algorithms.Math.fibonacci.direct">
        function <span class="apidocSignatureSpan">algorithms.Math.fibonacci.</span>direct
        <span class="apidocSignatureSpan">(number)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">direct = function (number) {
  var phi = (1 + Math.sqrt(5)) / 2;
  return Math.floor(Math.pow(phi, number) / Math.sqrt(5) + 0.5);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.Math.fibonacci.exponential" id="apidoc.element.algorithms.Math.fibonacci.exponential">
        function <span class="apidocSignatureSpan">algorithms.Math.fibonacci.</span>exponential
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exponential = function (n) {
  return n &lt; 2 ? n : fibExponential(n - 1) + fibExponential(n - 2);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.Math.fibonacci.logarithmic" id="apidoc.element.algorithms.Math.fibonacci.logarithmic">
        function <span class="apidocSignatureSpan">algorithms.Math.fibonacci.</span>logarithmic
        <span class="apidocSignatureSpan">(number)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">logarithmic = function (number) {
  // Transforms [f_1, f_0] to [f_2, f_1] and so on.
  var nextFib = [[1, 1], [1, 0]];

  var matrixMultiply = function (a, b) {
    return [[a[0][0] * b[0][0] + a[0][1] * b[1][0],
             a[0][0] * b[0][1] + a[0][1] * b[1][1]],
            [a[1][0] * b[0][0] + a[1][1] * b[1][0],
             a[1][0] * b[0][1] + a[1][1] * b[1][1]]];
  };

  var transform = power(nextFib, number, matrixMultiply, [[1, 0], [0, 1]]);

  // [f_n, f_{n-1}] = Transform * [f_0, f_{-1}] = Transform * [0, 1]
  // Hence the result is the first row of Transform multiplied by [0, 1],
  // which is the same as transform[0][1].
  return transform[0][1];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.Math.fibonacci.withMemoization" id="apidoc.element.algorithms.Math.fibonacci.withMemoization">
        function <span class="apidocSignatureSpan">algorithms.Math.fibonacci.</span>withMemoization
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">withMemoization = function (n) {
  if (cache[n] === undefined) {
    cache[n] = fib(n - 1) + fib(n - 2);
  }
  return cache[n];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.algorithms.Math.gcd" id="apidoc.module.algorithms.Math.gcd">module algorithms.Math.gcd</a></h1>


    <h2>
        <a href="#apidoc.element.algorithms.Math.gcd.gcd" id="apidoc.element.algorithms.Math.gcd.gcd">
        function <span class="apidocSignatureSpan">algorithms.Math.</span>gcd
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">gcd = function (a, b) {
  var tmp = a;
  a = Math.max(a, b);
  b = Math.min(tmp, b);
  while (b !== 0) {
    tmp = b;
    b = a % b;
    a = tmp;
  }

  return a;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.Math.gcd.binary" id="apidoc.element.algorithms.Math.gcd.binary">
        function <span class="apidocSignatureSpan">algorithms.Math.gcd.</span>binary
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">binary = function (a, b) {

  // GCD(0,b) == b; GCD(a,0) == a, GCD(0,0) == 0
  if (a === 0) {
    return b;
  }

  if (b === 0) {
    return a;
  }

  var shift;
  // Let shift = log(K), where K is the greatest power of 2
  // dividing both a and b
  for (shift = 0; ((a | b) &amp; 1) === 0; ++shift) {
    a &gt;&gt;= 1;
    b &gt;&gt;= 1;
  }

  // Remove all factors of 2 in a -- they are not common
  // Note: a is not zero, so while will terminate
  while ((a &amp; 1) === 0) {
    a &gt;&gt;= 1;
  }

  var tmp;

  // From here on, a is always odd
  do {
    // Remove all factors of 2 in b -- they are not common
    // Note: b is not zero, so while will terminate
    while ((b &amp; 1) === 0) {
      b &gt;&gt;= 1;
    }

    // Now a and b are both odd. Swap if necessary so a &lt;= b,
    // then set b = b - a (which is even).
    if (a &gt; b) {
      tmp = b;
      b = a;
      a = tmp;
    }

    b -= a;  // Here b &gt;= a
  } while (b !== 0);

  // restore common factors of 2
  return a &lt;&lt; shift;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.algorithms.Math.lcm" id="apidoc.module.algorithms.Math.lcm">module algorithms.Math.lcm</a></h1>


    <h2>
        <a href="#apidoc.element.algorithms.Math.lcm.lcm" id="apidoc.element.algorithms.Math.lcm.lcm">
        function <span class="apidocSignatureSpan">algorithms.Math.</span>lcm
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lcm = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.Math.lcm.binary" id="apidoc.element.algorithms.Math.lcm.binary">
        function <span class="apidocSignatureSpan">algorithms.Math.lcm.</span>binary
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">binary = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.algorithms.Math.powerSet" id="apidoc.module.algorithms.Math.powerSet">module algorithms.Math.powerSet</a></h1>


    <h2>
        <a href="#apidoc.element.algorithms.Math.powerSet.powerSet" id="apidoc.element.algorithms.Math.powerSet.powerSet">
        function <span class="apidocSignatureSpan">algorithms.Math.</span>powerSet
        <span class="apidocSignatureSpan">(array)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">powerSet = function (array) {

  if (array.length === 0) {
    return [];
  }

  var powerSet = [];
  var cache = [];
  var i;

  for (i = 0; i &lt; array.length; i++) {
    cache[i] = true;
  }

  for (i = 0; i &lt; Math.pow(2, array.length); i++) {

    powerSet.push([]);

    for (var j = 0; j &lt; array.length; j++) {

      if (i % Math.pow(2, j) === 0) {
        cache[j] = !cache[j];
      }

      if (cache[j]) {
        powerSet[i].push(array[j]);
      }

    }
  }

  return powerSet;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.Math.powerSet.recursive" id="apidoc.element.algorithms.Math.powerSet.recursive">
        function <span class="apidocSignatureSpan">algorithms.Math.powerSet.</span>recursive
        <span class="apidocSignatureSpan">(array)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">recursive = function (array) {
  if (array.length === 0) {
    return [];
  } else if (array.length === 1) {
    return [ [], [ array[0] ] ];
  } else {
    var powerSet = [];
    var firstElem = array[0];

    array.splice(0, 1);

    powerSetRecursive(array).forEach(function (elem) {
      powerSet.push(elem);
      var withFirstElem = [ firstElem ];
      withFirstElem.push.apply(withFirstElem, elem);
      powerSet.push(withFirstElem);
    });

    return powerSet;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
assert(fourElementTest.length === 16);

    });
  });

  describe('#recursive()', function () {
    it('should return the right elements of power set', function () {
var zeroElementTest = powerSet.<span class="apidocCodeKeywordSpan">recursive</span>([]);
assert(zeroElementTest.length === 0);

var oneElementTest = powerSet.recursive([0]);
assert(testArrayInArray([], oneElementTest));
assert(testArrayInArray([0], oneElementTest));
assert(oneElementTest.length === 2);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.algorithms.Math.primalityTests" id="apidoc.module.algorithms.Math.primalityTests">module algorithms.Math.primalityTests</a></h1>


    <h2>
        <a href="#apidoc.element.algorithms.Math.primalityTests.naiveTest" id="apidoc.element.algorithms.Math.primalityTests.naiveTest">
        function <span class="apidocSignatureSpan">algorithms.Math.primalityTests.</span>naiveTest
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">naiveTest = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.Math.primalityTests.trialDivisionTest" id="apidoc.element.algorithms.Math.primalityTests.trialDivisionTest">
        function <span class="apidocSignatureSpan">algorithms.Math.primalityTests.</span>trialDivisionTest
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">trialDivisionTest = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.algorithms.Search" id="apidoc.module.algorithms.Search">module algorithms.Search</a></h1>


    <h2>
        <a href="#apidoc.element.algorithms.Search.bfs" id="apidoc.element.algorithms.Search.bfs">
        function <span class="apidocSignatureSpan">algorithms.Search.</span>bfs
        <span class="apidocSignatureSpan">(root, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bfs = function (root, callback) {
  var q = new Queue();
  q.push(root);
  var node;
  while (!q.isEmpty()) {
    node = q.pop();
    callback(node.value);
    if (node.left) q.push(node.left);
    if (node.right) q.push(node.right);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.Search.binarySearch" id="apidoc.element.algorithms.Search.binarySearch">
        function <span class="apidocSignatureSpan">algorithms.Search.</span>binarySearch
        <span class="apidocSignatureSpan">(sortedArray, element)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">binarySearch = function (sortedArray, element) {
  var init = 0,
      end = sortedArray.length - 1;

  while (end &gt;= init) {
    var m = ((end - init) &gt;&gt; 1) + init;
    if (sortedArray[m] === element) return m;

    if (sortedArray[m] &lt; element) init = m + 1;
    else end = m - 1;
  }

  return -1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.Search.dfs" id="apidoc.element.algorithms.Search.dfs">
        function <span class="apidocSignatureSpan">algorithms.Search.</span>dfs
        <span class="apidocSignatureSpan">(node, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dfs = function (node, callback) {
  if (node) {
    inOrder(node.left, callback);
    callback(node.value);
    inOrder(node.right, callback);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.Search.ternarySearch" id="apidoc.element.algorithms.Search.ternarySearch">
        function <span class="apidocSignatureSpan">algorithms.Search.</span>ternarySearch
        <span class="apidocSignatureSpan">(fn, left, right, precision)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ternarySearch = function (fn, left, right, precision) {
  while (Math.abs(right - left) &gt; precision) {
    var leftThird = left + (right - left) / 3,
        rightThird = right - (right - left) / 3;

    if (fn(leftThird) &lt; fn(rightThird))
      left = leftThird; else
      right = rightThird;
  }
  return (left + right) / 2;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.algorithms.Search.dfs" id="apidoc.module.algorithms.Search.dfs">module algorithms.Search.dfs</a></h1>


    <h2>
        <a href="#apidoc.element.algorithms.Search.dfs.dfs" id="apidoc.element.algorithms.Search.dfs.dfs">
        function <span class="apidocSignatureSpan">algorithms.Search.</span>dfs
        <span class="apidocSignatureSpan">(node, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dfs = function (node, callback) {
  if (node) {
    inOrder(node.left, callback);
    callback(node.value);
    inOrder(node.right, callback);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.Search.dfs.postOrder" id="apidoc.element.algorithms.Search.dfs.postOrder">
        function <span class="apidocSignatureSpan">algorithms.Search.dfs.</span>postOrder
        <span class="apidocSignatureSpan">(node, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">postOrder = function (node, callback) {
  if (node) {
    postOrder(node.left, callback);
    postOrder(node.right, callback);
    callback(node.value);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Post-order traversal from the given node.
 */
AVLTree.prototype.postOrder = function (current, callback) {
  if (!current) {
    return;
  }

  this.<span class="apidocCodeKeywordSpan">postOrder</span>(current.left, callback);
  this.postOrder(current.right, callback);
  if (typeof callback === 'function') {
    callback(current);
  }
};

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.Search.dfs.preOrder" id="apidoc.element.algorithms.Search.dfs.preOrder">
        function <span class="apidocSignatureSpan">algorithms.Search.dfs.</span>preOrder
        <span class="apidocSignatureSpan">(node, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">preOrder = function (node, callback) {
  if (node) {
    callback(node.value);
    preOrder(node.left, callback);
    preOrder(node.right, callback);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
AVLTree.prototype.preOrder = function (current, callback) {
  if (!current) {
    return;
  }
  if (typeof callback === 'function') {
    callback(current);
  }
  this.<span class="apidocCodeKeywordSpan">preOrder</span>(current.left, callback);
  this.preOrder(current.right, callback);
};

/**
 * Finds a node by its value.
 */
AVLTree.prototype.find = function (value) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.algorithms.Sorting" id="apidoc.module.algorithms.Sorting">module algorithms.Sorting</a></h1>


    <h2>
        <a href="#apidoc.element.algorithms.Sorting.bubbleSort" id="apidoc.element.algorithms.Sorting.bubbleSort">
        function <span class="apidocSignatureSpan">algorithms.Sorting.</span>bubbleSort
        <span class="apidocSignatureSpan">(a, comparatorFn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bubbleSort = function (a, comparatorFn) {
  var comparator = new Comparator(comparatorFn);
  var n = a.length;
  var bound = n - 1;
  var check = false;
  for (var i = 0; i &lt; n - 1; i++) {
    var newbound = 0;
    for (var j = 0; j &lt; bound; j++) {
      if (comparator.greaterThan(a[j], a[j + 1])) {
        var tmp = a[j];
        a[j] = a[j + 1];
        a[j + 1] = tmp;
        newbound = j;
        check = true;
      }
    }
    if (!check)
      return a;
    bound = newbound;
  }
  return a;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.Sorting.countingSort" id="apidoc.element.algorithms.Sorting.countingSort">
        function <span class="apidocSignatureSpan">algorithms.Sorting.</span>countingSort
        <span class="apidocSignatureSpan">(array)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">countingSort = function (array) {
  var max = maximumKey(array);
  var auxiliaryArray = [];
  var length = array.length;
  var i;

  for (i = 0; i &lt; length; i++) {
    var position = array[i].key;

    if (auxiliaryArray[position] === undefined) {
      auxiliaryArray[position] = [];
    }

    auxiliaryArray[position].push(array[i]);
  }

  array = [];
  var pointer = 0;

  for (i = 0; i &lt;= max; i++) {
    if (auxiliaryArray[i] !== undefined) {
      var localLength = auxiliaryArray[i].length;

      for (var j = 0; j &lt; localLength; j++) {
        array[pointer++] = auxiliaryArray[i][j];
      }
    }
  }

  return array;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.Sorting.heapSort" id="apidoc.element.algorithms.Sorting.heapSort">
        function <span class="apidocSignatureSpan">algorithms.Sorting.</span>heapSort
        <span class="apidocSignatureSpan">(array, comparatorFn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">heapSort = function (array, comparatorFn) {

  var minHeap = new MinHeap(comparatorFn);
  minHeap.heapify(array);

  var result = [];
  while (!minHeap.isEmpty())
    result.push(minHeap.extract());

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.Sorting.insertionSort" id="apidoc.element.algorithms.Sorting.insertionSort">
        function <span class="apidocSignatureSpan">algorithms.Sorting.</span>insertionSort
        <span class="apidocSignatureSpan">(vector, comparatorFn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">insertionSort = function (vector, comparatorFn) {
  var comparator = new Comparator(comparatorFn);

  for (var i = 1, len = vector.length; i &lt; len; i++) {
    var aux = vector[i],
      j = i;

    while (j &gt; 0 &amp;&amp; comparator.lessThan(aux, vector[j - 1])) {
      vector[j] = vector[j - 1];
      j--;
    }

    vector[j] = aux;
  }

  return vector;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.Sorting.mergeSort" id="apidoc.element.algorithms.Sorting.mergeSort">
        function <span class="apidocSignatureSpan">algorithms.Sorting.</span>mergeSort
        <span class="apidocSignatureSpan">(a, compareFn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mergeSort = function (a, compareFn) {
  var comparator = new Comparator(compareFn);

  return (function mergeSort(a) {
    if (a.length &gt; 1) {
      var middle = a.length &gt;&gt; 1;
      var left = mergeSort(a.slice(0, middle));
      var right = mergeSort(a.slice(middle));
      a = merge(left, right, comparator);
    }

    return a;
  })(a);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.Sorting.quicksort" id="apidoc.element.algorithms.Sorting.quicksort">
        function <span class="apidocSignatureSpan">algorithms.Sorting.</span>quicksort
        <span class="apidocSignatureSpan">(array, comparatorFn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">quicksort = function (array, comparatorFn) {

  var comparator = new Comparator(comparatorFn);

  return (function quicksort(array, lo, hi) {
    while (lo &lt; hi) {
      var p = partition(array, comparator, lo, hi);
      //Chooses only the smallest partition to use recursion on and
      //tail-optimize the other. This guarantees O(log n) space in worst case.
      if (p - lo &lt; hi - p) {
        quicksort(array, lo, p - 1);
        lo = p + 1;
      } else {
        quicksort(array, p + 1, hi);
        hi = p - 1;
      }
    }

    return array;
  })(array, 0, array.length - 1);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.Sorting.radixSort" id="apidoc.element.algorithms.Sorting.radixSort">
        function <span class="apidocSignatureSpan">algorithms.Sorting.</span>radixSort
        <span class="apidocSignatureSpan">(array)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">radixSort = function (array) {
  var max = maximumKey(array);
  var digitsMax = (max === 0 ? 1 :
    1 + Math.floor(Math.log(max) / Math.log(10))); // log base 10

  for (var i = 0; i &lt; digitsMax; i++) {
    array = auxiliaryCountingSort(array, i);
  }

  return array;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.Sorting.selectionSort" id="apidoc.element.algorithms.Sorting.selectionSort">
        function <span class="apidocSignatureSpan">algorithms.Sorting.</span>selectionSort
        <span class="apidocSignatureSpan">(a, comparatorFn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selectionSort = function (a, comparatorFn) {
  var comparator = new Comparator(comparatorFn);
  var n = a.length;
  for (var i = 0; i &lt; n - 1; i++) {
    var min = i;
    for (var j = i + 1; j &lt; n; j++) {
      if (comparator.greaterThan(a[min], a[j])) {
        min = j;
      }
    }
    if (min !== i) {
      var tmp = a[i];
      a[i] = a[min];
      a[min] = tmp;
    }
  }

  return a;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.Sorting.shellSort" id="apidoc.element.algorithms.Sorting.shellSort">
        function <span class="apidocSignatureSpan">algorithms.Sorting.</span>shellSort
        <span class="apidocSignatureSpan">(array, comparatorFn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">shellSort = function (array, comparatorFn) {
  var comparator = new Comparator(comparatorFn),
    begin = 0,
    end = array.length - 1,
    gap = parseInt((end - begin + 1) / 2),
    i = 0, j = 0, temp = 0;

  while (gap &gt;= 1) {
    for (i = begin + gap;i &lt;= end;i += 1) {
      temp = array[i];
      j = i - gap;
      while (j &gt;= begin &amp;&amp; comparator.greaterThan(array[j], temp)) {
        array[j + gap] = array[j];
        j = j - gap;
      }
      array[j + gap] = temp;
    }
    gap = parseInt(gap / 2);
  }

  return array;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.Sorting.shortBubbleSort" id="apidoc.element.algorithms.Sorting.shortBubbleSort">
        function <span class="apidocSignatureSpan">algorithms.Sorting.</span>shortBubbleSort
        <span class="apidocSignatureSpan">(array, comparatorFn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function shortBubbleSort(array, comparatorFn) {
  var comparator = new Comparator(comparatorFn);
  var length = array.length - 1;
  var i = 0;

  for (i; i &lt; length; i++) {
    var current = array[i];
    var next = array[i+1];

<span class="apidocCodeCommentSpan">    /**
     * If the current value if greater than the next:
     * - set current value to next value;
     * - and set next value to current value;
     * - then reset iterator counter to rescan for values to be sorted.
     */
</span>
    if (comparator.greaterThan(current, next)) {
      array[i+1] = current;
      array[i] = next;
      i = -1;
    }
  }

  return array;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.algorithms.String" id="apidoc.module.algorithms.String">module algorithms.String</a></h1>


    <h2>
        <a href="#apidoc.element.algorithms.String.hamming" id="apidoc.element.algorithms.String.hamming">
        function <span class="apidocSignatureSpan">algorithms.String.</span>hamming
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hamming = function (a, b) {
  if (a.length !== b.length) {
    throw new Error('Strings must be equal in length');
  }

  var dist = 0;

  for (var i = 0; i &lt; a.length; i++) {
    if (a[i] !== b[i]) {
      dist++;
    }
  }

  return dist;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.String.knuthMorrisPratt" id="apidoc.element.algorithms.String.knuthMorrisPratt">
        function <span class="apidocSignatureSpan">algorithms.String.</span>knuthMorrisPratt
        <span class="apidocSignatureSpan">(text, pattern)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">knuthMorrisPratt = function (text, pattern) {
  var textLength = text.length;
  var patternLength = pattern.length;
  var m = 0;
  var i = 0;
  var table = buildTable(pattern);

  while (m + i &lt; textLength) {
    if (pattern[i] === text[m + i]) {
      if (i === patternLength - 1) {
        return m;
      }
      ++i;
    }
    else {
      if (table[i] &gt;= 0) {
        i = table[i];
        m = m + i - table[i];
      }
      else {
        i = 0;
        ++m;
      }
    }
  }

  return textLength;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.String.levenshtein" id="apidoc.element.algorithms.String.levenshtein">
        function <span class="apidocSignatureSpan">algorithms.String.</span>levenshtein
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">levenshtein = function (a, b) {
  var editDistance = [];
  var i, j;

  // Initialize the edit distance matrix. The first collumn contains
  // the values comparing the string a to an empty string b
  for (i = 0; i &lt;= a.length; i++) {
    editDistance[i] = [];
    editDistance[i][0] = i;
  }

  // And the first line the values comparint the string b to an empty string a
  for (j = 0; j &lt;= b.length; j++) {
    editDistance[0][j] = j;
  }
  for (i = 1; i &lt;= a.length; i++) {
    for (j = 1; j &lt;= b.length; j++) {
      // Finds the minimum cost for keeping the two strings equal
      editDistance[i][j] =
        Math.min(
          editDistance[i - 1][j - 1], // if we replace a[i] by b[j]
          editDistance[i - 1][j], // if we delete the char from a
          editDistance[i][j - 1] // if we add the char from b
        ) +
        (a[i - 1] !== b[j - 1] ? 1 : 0);
    }
  }

  return editDistance[a.length][b.length];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.String.longestCommonSubsequence" id="apidoc.element.algorithms.String.longestCommonSubsequence">
        function <span class="apidocSignatureSpan">algorithms.String.</span>longestCommonSubsequence
        <span class="apidocSignatureSpan">(s1, s2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">longestCommonSubsequence = function (s1, s2) {
  // Multidimensional array for dynamic programming algorithm
  var cache = new Array(s1.length + 1);

  var i, j;

  for (i = 0; i &lt;= s1.length; i++) {
    cache[i] = new Int32Array(s2.length + 1);
  }

  // Fill in the cache
  for (i = 1; i &lt;= s1.length; i++) {
    for (j = 1; j &lt;= s2.length; j++) {
      if (s1[i - 1] === s2[j - 1]) {
        cache[i][j] = cache[i - 1][j - 1] + 1;
      } else {
        cache[i][j] = Math.max(cache[i][j - 1], cache[i - 1][j]);
      }
    }
  }

  // Build LCS from cache
  i = s1.length;
  j = s2.length;
  var lcs = '';

  while (cache[i][j] !== 0) {
    if (s1[i - 1] === s2[j - 1]) {
      lcs = s1[i - 1] + lcs;
      i--;
      j--;
    } else if (cache[i - 1][j] &gt; cache[i][j - 1]) {
      i--;
    } else {
      j--;
    }
  }

  return lcs;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.String.longestCommonSubstring" id="apidoc.element.algorithms.String.longestCommonSubstring">
        function <span class="apidocSignatureSpan">algorithms.String.</span>longestCommonSubstring
        <span class="apidocSignatureSpan">(s1, s2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">longestCommonSubstring = function (s1, s2) {
  // Multidimensional array for dynamic programming algorithm
  var cache = new Array(s1.length + 1);

  var i, j;

  for (i = 0; i &lt;= s1.length + 1; i++) {
    cache[i] = new Int32Array(s2.length + 1);
  }

  var lcsPosition = {};
  var lcsLength = 0;

  // Fill in the cache
  for (i = 1; i &lt;= s1.length; i++) {
    for (j = 1; j &lt;= s2.length; j++) {
      if (s1[i - 1] === s2[j - 1]) {
        cache[i][j] = cache[i - 1][j - 1] + 1;
        if (cache[i][j] &gt; lcsLength) {
          lcsPosition.i = i;
          lcsPosition.j = j;
          lcsLength = cache[i][j];
        }
      } else {
        cache[i][j] = 0;
      }
    }
  }

  var lcs = '';
  if (lcsLength) {
    lcs = s1.substring(lcsPosition.i - lcsLength, lcsPosition.i);
  }

  return lcs;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.String.rabinKarp" id="apidoc.element.algorithms.String.rabinKarp">
        function <span class="apidocSignatureSpan">algorithms.String.</span>rabinKarp
        <span class="apidocSignatureSpan">(s, pattern)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rabinKarp = function (s, pattern) {
  if (pattern.length === 0) return 0;

  var hashPattern = hash(pattern);
  var currentSubstring = s.substring(0, pattern.length);
  var hashCurrentSubstring;

  for (var i = pattern.length; i &lt;= s.length; i++) {
    if (hashCurrentSubstring === undefined) {
      hashCurrentSubstring = hash(currentSubstring);
    } else {
<span class="apidocCodeCommentSpan">      /*
       * Re-hash
       * Recalculates the hash representation of a word so that it isn't
       * necessary to traverse the whole word again
       */
</span>      hashCurrentSubstring -= currentSubstring.charCodeAt(0) *
        Math.pow(base, pattern.length - 1);
      hashCurrentSubstring *= base;
      hashCurrentSubstring += s.charCodeAt(i);

      currentSubstring = currentSubstring.substring(1) + s[i];
    }

    if (hashPattern === hashCurrentSubstring &amp;&amp;
        pattern === currentSubstring) {
      // Hack for the off-by-one when matching in the beginning of the string
      return i === pattern.length ? 0 : i - pattern.length + 1;
    }
  }

  return -1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.algorithms.String.huffman" id="apidoc.module.algorithms.String.huffman">module algorithms.String.huffman</a></h1>


    <h2>
        <a href="#apidoc.element.algorithms.String.huffman.decode" id="apidoc.element.algorithms.String.huffman.decode">
        function <span class="apidocSignatureSpan">algorithms.String.huffman.</span>decode
        <span class="apidocSignatureSpan">(encoding, encodedString)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decode = function (encoding, encodedString) {
  if (Array.isArray(encodedString)) {
    encodedString = decompress(encodedString);
  }

  // We can make use of the fact that encoding mapping is always one-to-one
  // and rely on the power of JS hashes instead of building hand-made FSMs.
  var letterByCode = Object.keys(encoding).reduce(function (acc, letter) {
    acc[encoding[letter]] = letter;
    return acc;
  }, {});

  var decodedLetters = [];

  var unresolved = encodedString.split('').reduce(function (code, char) {
    code += char;
    var letter = letterByCode[code];
    if (letter) {
      decodedLetters.push(letter);
      code = '';
    }
    return code;
  }, '');

  if (unresolved) {
    throw new Error('Invalid string to decode.');
  }

  return decodedLetters.join('');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  messages.push(characters.join(''));
}

it('should decode previously encoded messages correctly', function () {
  messages.forEach(function (message) {
    var encoded = huffman.encode(message);
    var decoded = huffman.<span class="apidocCodeKeywordSpan">decode</span>(encoded.encoding, encoded.value);
    assert.equal(message, decoded);
    var encodedCompressed = huffman.encode(message, true);
    var decodedCompressed = huffman.decode(encodedCompressed.encoding,
                                           encodedCompressed.value);
    assert.equal(message, decodedCompressed);
  });
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.String.huffman.encode" id="apidoc.element.algorithms.String.huffman.encode">
        function <span class="apidocSignatureSpan">algorithms.String.huffman.</span>encode
        <span class="apidocSignatureSpan">(string, compressed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encode = function (string, compressed) {
  if (!string.length) {
    return {
      encoding: {},
      value: (compressed ? [] : '')
    };
  }

  var counter = {};
  string.split('').forEach(function (char) {
    counter[char] = (counter[char] || 0) + 1;
  });

  var letters = Object.keys(counter).map(function (char) {
    return {
      char: char,
      count: counter[char]
    };
  });

  var compare = function (a, b) {
    return a.count - b.count;
  };
  var less = function (a, b) {
    return a &amp;&amp; (b &amp;&amp; (a.count &lt; b.count) || !b);
  };

  letters.sort(compare);

  // Each time two least letters are merged into one, the result is pushing into
  // this buffer. Since the letters are pushing in ascending order of frequency,
  // no more sorting is ever required.
  var buffer = [];
  var lettersIndex = 0, bufferIndex = 0;

  var extractMinimum = function () {
    return less(letters[lettersIndex], buffer[bufferIndex]) ?
      letters[lettersIndex++] : buffer[bufferIndex++];
  };

  for (var numLetters = letters.length; numLetters &gt; 1; --numLetters) {
    var a = extractMinimum(), b = extractMinimum();
    a.code = '0';
    b.code = '1';
    var union = {
      count: a.count + b.count,
      parts: [a, b]
    };
    buffer.push(union);
  }

  // At this point there is a single letter left.
  var root = extractMinimum();
  root.code = (letters.length &gt; 1) ? '' : '0';

  // Unroll the code recursively in reverse.
  (function unroll(parent) {
    if (parent.parts) {
      var a = parent.parts[0], b = parent.parts[1];
      a.code += parent.code;
      b.code += parent.code;
      unroll(a);
      unroll(b);
    }
  })(root);

  var encoding = letters.reduce(function (acc, letter) {
    acc[letter.char] = letter.code.split('').reverse().join('');
    return acc;
  }, {});

  // Finally, apply the encoding to the given string.
  var result = string.split('').map(function (char) {
    return encoding[char];
  }).join('');

  return {
    encoding: encoding,
    value: (compressed ? compress(result) : result)
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    characters.push(String.fromCharCode(charCode));
  }
  messages.push(characters.join(''));
}

it('should decode previously encoded messages correctly', function () {
  messages.forEach(function (message) {
    var encoded = huffman.<span class="apidocCodeKeywordSpan">encode</span>(message);
    var decoded = huffman.decode(encoded.encoding, encoded.value);
    assert.equal(message, decoded);
    var encodedCompressed = huffman.encode(message, true);
    var decodedCompressed = huffman.decode(encodedCompressed.encoding,
                                           encodedCompressed.value);
    assert.equal(message, decodedCompressed);
  });
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.algorithms.comparator" id="apidoc.module.algorithms.comparator">module algorithms.comparator</a></h1>


    <h2>
        <a href="#apidoc.element.algorithms.comparator.comparator" id="apidoc.element.algorithms.comparator.comparator">
        function <span class="apidocSignatureSpan">algorithms.</span>comparator
        <span class="apidocSignatureSpan">(compareFn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Comparator(compareFn) {
  if (compareFn) {
    this.compare = compareFn;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.algorithms.comparator.prototype" id="apidoc.module.algorithms.comparator.prototype">module algorithms.comparator.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.algorithms.comparator.prototype.compare" id="apidoc.element.algorithms.comparator.prototype.compare">
        function <span class="apidocSignatureSpan">algorithms.comparator.prototype.</span>compare
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compare = function (a, b) {
  if (a === b) return 0;
  return a &lt; b ? -1 : 1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
Comparator.prototype.compare = function (a, b) {
  if (a === b) return 0;
  return a &lt; b ? -1 : 1;
};

Comparator.prototype.lessThan = function (a, b) {
  return this.<span class="apidocCodeKeywordSpan">compare</span>(a, b) &lt; 0;
};

Comparator.prototype.lessThanOrEqual = function (a, b) {
  return this.lessThan(a, b) || this.equal(a, b);
};

Comparator.prototype.greaterThan = function (a, b) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.comparator.prototype.equal" id="apidoc.element.algorithms.comparator.prototype.equal">
        function <span class="apidocSignatureSpan">algorithms.comparator.prototype.</span>equal
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">equal = function (a, b) {
  return this.compare(a, b) === 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

Comparator.prototype.lessThan = function (a, b) {
  return this.compare(a, b) &lt; 0;
};

Comparator.prototype.lessThanOrEqual = function (a, b) {
  return this.lessThan(a, b) || this.<span class="apidocCodeKeywordSpan">equal</span>(a, b);
};

Comparator.prototype.greaterThan = function (a, b) {
  return this.compare(a, b) &gt; 0;
};

Comparator.prototype.greaterThanOrEqual = function (a, b) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.comparator.prototype.greaterThan" id="apidoc.element.algorithms.comparator.prototype.greaterThan">
        function <span class="apidocSignatureSpan">algorithms.comparator.prototype.</span>greaterThan
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">greaterThan = function (a, b) {
  return this.compare(a, b) &gt; 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  if (root.value === e)
    return root;

  if (this._comparator.lessThan(e, root.value))
    return root.left &amp;&amp; this._find(e, root.left);

  if (this._comparator.<span class="apidocCodeKeywordSpan">greaterThan</span>(e, root.value))
    return root.right &amp;&amp; this._find(e, root.right);
};

/**
 * Substitute two nodes
 */
BST.prototype._replaceNodeInParent = function (currNode, newNode) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.comparator.prototype.greaterThanOrEqual" id="apidoc.element.algorithms.comparator.prototype.greaterThanOrEqual">
        function <span class="apidocSignatureSpan">algorithms.comparator.prototype.</span>greaterThanOrEqual
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">greaterThanOrEqual = function (a, b) {
  return this.greaterThan(a, b) || this.equal(a, b);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (!array.length) {
  return false;
}
var cmp = new Comparator(compareFn);

// Find pivot and successor indices.
var pivot = array.length - 1;
while (pivot &amp;&amp; cmp.<span class="apidocCodeKeywordSpan">greaterThanOrEqual</span>(array[pivot - 1], array[pivot])) {
  pivot -= 1;
}
if (!pivot) {
  // Permutation is sorted in descending order.
  return false;
}
var pivotValue = array[--pivot];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.comparator.prototype.lessThan" id="apidoc.element.algorithms.comparator.prototype.lessThan">
        function <span class="apidocSignatureSpan">algorithms.comparator.prototype.</span>lessThan
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lessThan = function (a, b) {
  return this.compare(a, b) &lt; 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      this.root = new Node(value);
      this._size++;
      return;
    }
    parent = this.root;
  }

  var child = this._comparator.<span class="apidocCodeKeywordSpan">lessThan</span>(value, parent.value) ? 'left' : '
;right';
  if (parent[child]) {
    this.insert(value, parent[child]);
  } else {
    parent[child] = new Node(value, parent);
    this._size++;
  }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.comparator.prototype.lessThanOrEqual" id="apidoc.element.algorithms.comparator.prototype.lessThanOrEqual">
        function <span class="apidocSignatureSpan">algorithms.comparator.prototype.</span>lessThanOrEqual
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lessThanOrEqual = function (a, b) {
  return this.lessThan(a, b) || this.equal(a, b);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
if (!pivot) {
  // Permutation is sorted in descending order.
  return false;
}
var pivotValue = array[--pivot];
var successor = array.length - 1;
while (cmp.<span class="apidocCodeKeywordSpan">lessThanOrEqual</span>(array[successor], pivotValue)) {
  successor -= 1;
}

// Swap values.
array[pivot] = array[successor];
array[successor] = pivotValue;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.algorithms.comparator.prototype.reverse" id="apidoc.element.algorithms.comparator.prototype.reverse">
        function <span class="apidocSignatureSpan">algorithms.comparator.prototype.</span>reverse
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reverse = function () {
  var originalCompareFn = this.compare;
  this.compare = function (a, b) {
    return originalCompareFn(b, a);
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *
 * To avoid code repetition, the Min Heap is used just with
 * a reverse comparator;
 */
function MaxHeap(compareFn) {

MinHeap.call(this, compareFn);
this._comparator.<span class="apidocCodeKeywordSpan">reverse</span>();
}

MaxHeap.prototype = new MinHeap();

module.exports = {
MinHeap: MinHeap,
MaxHeap: MaxHeap
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>